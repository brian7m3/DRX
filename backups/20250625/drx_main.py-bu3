#!/usr/bin/env python3

from datetime import datetime

import os
import sys
import time
import threading
import configparser
import serial
import curses
import subprocess
import random
import re
import RPi.GPIO as GPIO#!/usr/bin/env python3
import configparser
import RPi.GPIO as GPIO
import traceback
import wave
import contextlib
import shutil
import itertools
import json
import string
import inspect

# Get the directory where the script is located
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DEBUG_LOG_PATH = os.path.join(SCRIPT_DIR, "debug.log")

def debug_log(msg):
    if not ENABLE_DEBUG_LOGGING:
        return
    with open(DEBUG_LOG_PATH, 'a') as f:
        f.write(msg + '\n')

SCRIPT_NAME = "DRX"
VERSION = "2.02"

STATE_FILE = '/tmp/drx_state.json'
WEBCMD_FILE = '/tmp/drx_webcmd.json'
LOG_WEB_FILE = '/tmp/drx_webconsole.log'

serial_buffer = ""
serial_history = []
currently_playing = ""
currently_playing_info = ""
currently_playing_info_timestamp = 0
playing_end_time = 0
playback_status = ""
rotation_active = {}
current_playback_thread = None
serial_port_missing = False
sound_card_missing = False
playback_lock = threading.Lock()
remote_device_active = False
cos_active = False
DRX_START_TIME = time.time()
script_dir = os.path.dirname(os.path.realpath(__file__))
config_file_path = os.path.join(script_dir, 'config.ini')
log_file_path = os.path.join(script_dir, 'drx_error.log')
alternate_series_pointers = {}         # key: tuple(bases), value: current pointer/index (which base to play next)
alternate_series_track_pointers = {}   # key: tuple(bases), value: dict of base -> current track index (starts at 1)
alternate_series_last_played = {}      # key: tuple(bases), value: dict of base -> last_played_time
message_timer_last_played = 0   # timestamp of last play
message_timer_value = None      # stores the config value
last_message_timer_time = 0 

# --- Config Loading & Validation ---
DEFAULTS = {
    "Sound": {
        "directory": "/tmp/sounds",
        "extension": ".wav",
        "device": "default"
    },
    "GPIO": {
        "cos_pin": 23,
        "cos_activate_level": True,
        "remote_busy_pin": 25,
        "remote_busy_activate_level": True,
        "cos_debounce_time": 0.5,
        "max_cos_interruptions": 3
    },
    "Serial": {
        "port": "/dev/ttyUSB0",
        "baudrate": 9600,
        "timeout": 0.5
    },
    "Random": {
        "base": "3000",
        "end": "3099",
        "interval": "10"
    },
    "Rotation": {
        "base": "4000",
        "end": "4099",
        "interval": "10"
    },
    "SudoRandom": {
        "base": "5000",
        "end": "5099",
        "interval": "10"
    },
    "Direct": {
        "enabled": "true",
        "prefix": "P"
    },
    "General": {
        "Message Timer": "N"
    }
}
config_warnings = []

def get_config_value(section, key, fallback=None, cast_func=None, warn=None):
    global config_warnings
    if not config.has_section(section):
        config_warnings.append(f"Section [{section}] missing; using defaults.")
        val = DEFAULTS[section][key] if section in DEFAULTS and key in DEFAULTS[section] else fallback
        return cast_func(val) if cast_func else val
    if not config.has_option(section, key):
        config_warnings.append(f"Missing {key} in [{section}]; using default '{DEFAULTS.get(section, {}).get(key, fallback)}'.")
        val = DEFAULTS[section][key] if section in DEFAULTS and key in DEFAULTS[section] else fallback
        return cast_func(val) if cast_func else val
    raw = config[section][key]
    try:
        return cast_func(raw) if cast_func else raw
    except Exception as e:
        config_warnings.append(f"Invalid value for {key} in [{section}]: '{raw}' ({e}); using default '{DEFAULTS.get(section, {}).get(key, fallback)}'.")
        val = DEFAULTS[section][key] if section in DEFAULTS and key in DEFAULTS[section] else fallback
        return cast_func(val) if cast_func else val

# ---- Message Timer global initialization ----
# After you load your config file with config.read(), add this:
def parse_message_timer(val):
    val = val.strip().upper()
    if val == "N":
        return "N"
    try:
        return int(val)
    except Exception:
        return "N"

def read_state():
    try:
        with open(STATE_FILE, 'r') as f:
            return json.load(f)
    except Exception:
        return {}

def parse_int_list(s, fallback=10, label="", section=""):
    vals = []
    for i, v in enumerate(s.split(',')):
        try:
            if float(v) != int(float(v)):
                config_warnings.append(f"{label} in [{section}]: '{v}' not integer, using {fallback}.")
                vals.append(int(fallback))
            else:
                vals.append(int(float(v)))
        except Exception:
            config_warnings.append(f"{label} in [{section}]: '{v}' invalid, using {fallback}.")
            vals.append(int(fallback))
    return vals

def parse_float_list(s, fallback=10, label="", section=""):
    vals = []
    for i, v in enumerate(s.split(',')):
        try:
            f = float(v)
            if f < 0:
                config_warnings.append(f"{label} in [{section}]: '{v}' < 0, using {fallback}.")
                f = float(fallback)
            elif f != int(f):
                config_warnings.append(f"{label} in [{section}]: '{v}' not integer, using {fallback}.")
                f = float(fallback)
            vals.append(int(f))
        except Exception:
            config_warnings.append(f"{label} in [{section}]: '{v}' invalid, using {fallback}.")
            vals.append(int(fallback))
    return vals

def match_code_file(f, code_str, ext):
    ext = ext.lower()
    f_lower = f.lower()
    original_code_str = code_str
    if code_str.startswith('P'):
        code_str = code_str[1:]
    code_str = code_str.lstrip('0')
    if f_lower.endswith(ext):
        base = f_lower[:-len(ext)]
        result = base == code_str or base.startswith(f"{code_str}-")
        debug_log(f"match_code_file: f={f}, code_str={original_code_str} (stripped={code_str}), ext={ext}, base={base}, result={result}")
        return result
    return False

config = configparser.ConfigParser()
config_ini_missing = False
try:
    found_files = config.read(config_file_path)
    if not found_files:
        config_ini_missing = True
        config_warnings.insert(0, f"config.ini missing at {config_file_path}; using all default values.")
except Exception as e:
    config_ini_missing = True
    config_warnings.insert(0, f"Failed to read config.ini: {e}; using all default values.")

ENABLE_DEBUG_LOGGING = get_config_value("Debug", "enable_debug_logging", "false", lambda x: str(x).lower() in ("1", "true", "yes"))

SOUND_DIRECTORY = get_config_value("Sound", "directory", DEFAULTS["Sound"]["directory"])
SOUND_FILE_EXTENSION = get_config_value("Sound", "extension", DEFAULTS["Sound"]["extension"])
SOUND_DEVICE = get_config_value("Sound", "device", DEFAULTS["Sound"]["device"])

COS_PIN = get_config_value("GPIO", "cos_pin", DEFAULTS["GPIO"]["cos_pin"], int)
COS_ACTIVE_LEVEL = get_config_value("GPIO", "cos_activate_level", DEFAULTS["GPIO"]["cos_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
REMOTE_BUSY_PIN = get_config_value("GPIO", "remote_busy_pin", DEFAULTS["GPIO"]["remote_busy_pin"], int)
REMOTE_BUSY_ACTIVE_LEVEL = get_config_value("GPIO", "remote_busy_activate_level", DEFAULTS["GPIO"]["remote_busy_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
COS_DEBOUNCE_TIME = get_config_value("GPIO", "cos_debounce_time", DEFAULTS["GPIO"]["cos_debounce_time"], float)
MAX_COS_INTERRUPTIONS = get_config_value("GPIO", "max_cos_interruptions", DEFAULTS["GPIO"]["max_cos_interruptions"], int)

SERIAL_PORT = get_config_value("Serial", "port", DEFAULTS["Serial"]["port"])
SERIAL_BAUDRATE = get_config_value("Serial", "baudrate", DEFAULTS["Serial"]["baudrate"], int)
SERIAL_TIMEOUT = get_config_value("Serial", "timeout", DEFAULTS["Serial"]["timeout"], float)

RANDOM_BASE = get_config_value("Random", "base", DEFAULTS["Random"]["base"])
RANDOM_END = get_config_value("Random", "end", DEFAULTS["Random"]["end"])
RANDOM_INTERVAL = get_config_value("Random", "interval", DEFAULTS["Random"]["interval"])
ROTATION_BASE = get_config_value("Rotation", "base", DEFAULTS["Rotation"]["base"])
ROTATION_END = get_config_value("Rotation", "end", DEFAULTS["Rotation"]["end"])
ROTATION_TIME = get_config_value("Rotation", "interval", DEFAULTS["Rotation"]["interval"])
SUDORANDOM_BASE = get_config_value("SudoRandom", "base", DEFAULTS["SudoRandom"]["base"])
SUDORANDOM_END = get_config_value("SudoRandom", "end", DEFAULTS["SudoRandom"]["end"])
SUDORANDOM_INTERVAL = get_config_value("SudoRandom", "interval", DEFAULTS["SudoRandom"]["interval"])
DIRECT_ENABLED = get_config_value("Direct", "enabled", DEFAULTS["Direct"]["enabled"], lambda x: str(x).lower() in ("1", "true", "yes"))
DIRECT_PREFIX = get_config_value("Direct", "prefix", DEFAULTS["Direct"]["prefix"])
message_timer_value = config.getint('General', 'Message Timer', fallback=1)

random_bases = parse_int_list(RANDOM_BASE, fallback=3000, label="Random base", section="Random")
random_ends = parse_int_list(RANDOM_END, fallback=3099, label="Random end", section="Random")
random_intervals = parse_float_list(RANDOM_INTERVAL, fallback=10, label="Random interval", section="Random")
rotation_bases = parse_int_list(ROTATION_BASE, fallback=4000, label="Rotation base", section="Rotation")
rotation_ends = parse_int_list(ROTATION_END, fallback=4099, label="Rotation end", section="Rotation")
rotation_times = parse_float_list(ROTATION_TIME, fallback=10, label="Rotation time", section="Rotation")
sudo_bases = parse_int_list(SUDORANDOM_BASE, fallback=5000, label="SudoRandom base", section="SudoRandom")
sudo_ends = parse_int_list(SUDORANDOM_END, fallback=5099, label="SudoRandom end", section="SudoRandom")
sudo_intervals = parse_float_list(SUDORANDOM_INTERVAL, fallback=10, label="SudoRandom interval", section="SudoRandom")

def validate_config_pairs():
    for bases, ends, label, section in [
        (random_bases, random_ends, "Random", "Random"),
        (rotation_bases, rotation_ends, "Rotation", "Rotation"),
        (sudo_bases, sudo_ends, "SudoRandom", "SudoRandom")
    ]:
        for i, (b, e) in enumerate(zip(bases, ends)):
            if e < b:
                config_warnings.append(f"{label} config: End {e} < Base {b} (index {i})")
validate_config_pairs()
# --------------------------------------------------

GPIO.setmode(GPIO.BCM)
GPIO.setup(REMOTE_BUSY_PIN, GPIO.OUT)
GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
GPIO.setup(COS_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

try:
    serial_port = serial.Serial(
        port=SERIAL_PORT,
        baudrate=SERIAL_BAUDRATE,
        timeout=SERIAL_TIMEOUT
    )
    serial_port.reset_input_buffer()
except Exception as e:
    serial_port = None
    serial_port_missing = True

random_last_played = {}
random_current_track = {}
rotation_last_played = {}
rotation_current_track = {}

sudo_random_last_interval = {}
sudo_random_interval_track = {}
sudo_random_played_in_cycle = {}
sudo_random_last_file = {}

playback_interrupt = threading.Event()
alternate_sequences = {}

def log_error(msg):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        with open(log_file_path, 'a') as f:
            f.write(f"[{timestamp}] {msg}\n")
    except Exception:
        print(f"[{timestamp}] Logging failed: {msg}")

def log_exception(context: str):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    exc = traceback.format_exc()
    try:
        with open(log_file_path, 'a') as f:
            f.write(f"[{timestamp}] Exception in {context}:\n{exc}\n")
    except Exception:
        print(f"[{timestamp}] Logging failed: {exc}")

def log_recent(entry):
    from datetime import datetime  # Make sure this is at the top of your file
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
    try:
        with open(LOG_WEB_FILE, "a") as f:
            f.write(f"{ts}: {entry}\n")
        # --- TRIM LOG FILE IF OVER 500 KB ---
        max_size = 500 * 1024  # 500 KB
        try:
            if os.path.getsize(LOG_WEB_FILE) > max_size:
                with open(LOG_WEB_FILE, "rb") as f:
                    f.seek(-max_size, os.SEEK_END)
                    data = f.read()
                # find first newline to avoid splitting a line
                first_nl = data.find(b'\n')
                if first_nl != -1:
                    data = data[first_nl+1:]
                with open(LOG_WEB_FILE, "wb") as f:
                    f.write(data)
        except Exception as e:
            pass  # If trimming fails, just ignore
    except Exception as e:
        log_error(f"log_recent failed: {e}")

if shutil.which("sox") is None:
    log_error("sox is not installed! 'P' mode will not work.")

def is_cos_active():
    override_enabled = config.getboolean('Debug', 'enable_cos_override', fallback=False) if config.has_section('Debug') else False
    override_path = "/tmp/cos_force"
    if override_enabled:
        try:
            with open(override_path, "r") as f:
                val = f.read().strip()
                if val == "1":
                    return True
                elif val == "0":
                    return False
        except FileNotFoundError:
            pass
        except Exception:
            log_exception("is_cos_active (override)")
    try:
        level = GPIO.input(COS_PIN)
        return (level == COS_ACTIVE_LEVEL)
    except Exception:
        log_exception("is_cos_active (GPIO.input)")
        return False

def handle_alternate_series(command):
    bases, alt_suffix, is_alt = parse_alternate_series(command)
    debug_log(f"ALTERNATE DEBUG: command={command}, bases={bases}, alt_suffix={alt_suffix}, is_alt={is_alt}")
    if not is_alt or not bases:
        return False  # Not an alternate command

    # --- Parse suffixes ---
    suffix = alt_suffix.upper() if alt_suffix else ""
    repeat = 'R' in suffix
    pausing = 'P' in suffix
    interruptible = ('I' in suffix) or ('i' in suffix)  # case-insensitive I

    debug_log(f"ALTERNATE DEBUG: suffix={suffix}, repeat={repeat}, pausing={pausing}, interruptible={interruptible}")

    key = tuple(bases)
    if key not in alternate_series_pointers:
        alternate_series_pointers[key] = 0

    if len(bases) > 1:
        pointer = alternate_series_pointers[key]
        base_to_play = bases[pointer]
        debug_log(f"ALTERNATE DEBUG: pointer={pointer}, base_to_play={base_to_play}")
        # advance pointer only if series has more than one track
        alternate_series_pointers[key] = (pointer + 1) % len(bases)
    else:
        # single track: always play it, do not advance
        base_to_play = bases[0]
        debug_log(f"ALTERNATE DEBUG: single track, base_to_play={base_to_play}")

    code_str = f"P{base_to_play:04d}"
    debug_log(f"ALTERNATE DEBUG: code_str={code_str}")
    play_direct_track(code_str, interruptible=interruptible, repeat=repeat, pausing=pausing)

    return True  # Handled as alternate

def play_sound(filename, interruptible=False, pausing=False, repeating=False, playback_token=None):
    import os
    import time
    import subprocess
    global currently_playing, currently_playing_info, currently_playing_info_timestamp, playing_end_time, playback_interrupt, playback_status, sound_card_missing, current_playback_token, MAX_COS_INTERRUPTIONS

    debug_log(f"play_sound: filename={filename} interruptible={interruptible} pausing={pausing} repeating={repeating}")

    currently_playing = os.path.splitext(os.path.basename(filename))[0]
    currently_playing_info = f"Playing {filename}"
    currently_playing_info_timestamp = time.time()
    playback_status = "Playing"
    write_state()

    success = False
    interrupted = False

    try:
        if repeating:
            playback_status = "Playing (Repeat Mode)"
            write_state()
            debug_log("REPEAT MODE ACTIVE")
            cos_interruptions = 0
            ignore_cos = False
            while True:
                # Only wait for COS to go inactive if not in final (ignore COS) mode
                if not ignore_cos:
                    while is_cos_active() and not playback_interrupt.is_set():
                        playback_status = "Pending Restart (Repeat Mode)"   # <-- changed/added
                        write_state()
                        time.sleep(0.05)
                        if playback_token is not None and playback_token != current_playback_token:
                            interrupted = True
                            return
                    playback_status = "Playing (Repeat Mode)"  # <-- changed/added
                    write_state()
                GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)
                try:
                    proc = subprocess.Popen(
                        ['aplay', '-D', SOUND_DEVICE, filename],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                except Exception as e:
                    debug_log("Exception in REPEAT mode (Popen):", e)
                    import traceback
                    traceback.print_exc()
                    break

                was_interrupted = False
                while proc.poll() is None:
                    if playback_token is not None and playback_token != current_playback_token:
                        proc.terminate()
                        was_interrupted = True
                        interrupted = True
                        break
                    if not ignore_cos and is_cos_active():
                        cos_interruptions += 1
                        debug_log(f"Repeat mode: COS interruptions so far: {cos_interruptions}")
                        if cos_interruptions >= MAX_COS_INTERRUPTIONS:
                            debug_log("Repeat mode: max_cos_interruptions reached, will ignore COS from now on. Letting current playback continue.")
                            ignore_cos = True
                            # Do NOT terminate, do NOT set was_interrupted.
                            # Just break out of THIS loop and let the sound continue.
                            break
                        debug_log("COS active: stopping and will repeat")
                        proc.terminate()
                        time.sleep(0.1)
                        if proc.poll() is None:
                            proc.kill()
                        was_interrupted = True
                        interrupted = True
                        break
                    if playback_interrupt.is_set():
                        proc.terminate()
                        was_interrupted = True
                        interrupted = True
                        break
                    time.sleep(0.05)
                # Only terminate if proc was actually interrupted!
                if was_interrupted and proc.poll() is None:
                    proc.kill()
                proc.wait()

                # If we're now in ignore_cos mode (final allowed play), finish and exit after this play
                if ignore_cos:
                    debug_log("WAV played all the way through (final allowed play), ending repeat mode.")
                    success = True
                    break

                if not was_interrupted:
                    debug_log("WAV played all the way through, ending repeat mode.")
                    success = True
                    break
                if playback_interrupt.is_set() or (playback_token is not None and playback_token != current_playback_token):
                    break

            GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
        elif pausing:
            playback_status = "Playing (Pause Mode)"
            write_state()
            total_duration = get_duration_wav(filename)
            played_duration = 0
            cos_interruptions = 0
            while played_duration < total_duration:
                while is_cos_active() and not playback_interrupt.is_set():
                    playback_status = "Paused (Paused Mode)"   # <-- changed/added
                    write_state()
                    time.sleep(0.05)
                    if playback_token is not None and playback_token != current_playback_token:
                        interrupted = True
                        return
                playback_status = "Playing (Pause Mode)"   # <-- changed/added
                write_state()
                GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)
                sox_cmd = [
                    'sox', filename, '-t', 'wav', '-', 'trim', f'{played_duration}'
                ]
                try:
                    proc1 = subprocess.Popen(sox_cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
                    proc2 = subprocess.Popen(['aplay', '-D', SOUND_DEVICE], stdin=proc1.stdout, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    proc1.stdout.close()
                except Exception as e:
                    debug_log("Exception in PAUSING mode (Popen):", e)
                    import traceback
                    traceback.print_exc()
                    break

                was_interrupted = False
                start_time = time.time()
                while proc2.poll() is None:
                    if playback_token is not None and playback_token != current_playback_token:
                        proc2.terminate()
                        proc1.terminate()
                        was_interrupted = True
                        interrupted = True
                        break
                    if is_cos_active():
                        debug_log(f"COS active: pausing playback at {played_duration}")
                        proc2.terminate()
                        proc1.terminate()
                        time.sleep(0.1)
                        if proc2.poll() is None:
                            proc2.kill()
                        if proc1.poll() is None:
                            proc1.kill()
                        was_interrupted = True
                        interrupted = True
                        played_duration += time.time() - start_time
                        cos_interruptions += 1
                        debug_log(f"Pause mode: COS interruptions so far: {cos_interruptions}")
                        if cos_interruptions >= MAX_COS_INTERRUPTIONS:
                            debug_log("Pause mode: max_cos_interruptions reached, aborting pause mode.")
                            played_duration = total_duration
                        break
                    if playback_interrupt.is_set():
                        proc2.terminate()
                        proc1.terminate()
                        was_interrupted = True
                        interrupted = True
                        break
                    time.sleep(0.05)
                if proc2.poll() is None:
                    proc2.kill()
                if proc1.poll() is None:
                    proc1.kill()
                if not was_interrupted or playback_interrupt.is_set():
                    break
            if not interrupted:
                success = True
            GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
        else:
            playback_status = "Playing"
            write_state()
            GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)
            debug_log("NORMAL/INTERRUPTIBLE MODE")
            try:
                proc = subprocess.Popen(
                    ['aplay', '-D', SOUND_DEVICE, filename],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except Exception as e:
                debug_log("Exception starting aplay:", e)
                interrupted = True
                return

            try:
                while proc.poll() is None:
                    if playback_token is not None and playback_token != current_playback_token:
                        proc.terminate()
                        interrupted = True
                        break
                    if interruptible and is_cos_active():
                        debug_log("COS became ACTIVE, interrupting playback")
                        proc.terminate()
                        time.sleep(0.2)
                        if proc.poll() is None:
                            proc.kill()
                        interrupted = True
                        break
                    if playback_interrupt.is_set():
                        proc.terminate()
                        interrupted = True
                        break
                    time.sleep(0.05)
                if not interrupted:
                    success = True
            finally:
                if proc.poll() is None:
                    proc.kill()
                proc.wait()
            GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
    finally:
        currently_playing = ""
        currently_playing_info = ""
        currently_playing_info_timestamp = 0
        playback_status = "Idle"
        write_state()
        GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)

        # --- LOGGING FOR ALL PLAY ATTEMPTS ---
        play_mode = 'repeat' if repeating else 'pause' if pausing else 'normal'
        if success:
            log_recent(f"Play: {os.path.basename(filename)} [{play_mode}] - successful")
        elif interrupted:
            log_recent(f"Play: {os.path.basename(filename)} [{play_mode}] - interrupted")
        else:
            log_recent(f"Play: {os.path.basename(filename)} [{play_mode}] - playback error")

def is_remote_device_active():
    try:
        level = GPIO.input(REMOTE_BUSY_PIN)
        return (level == REMOTE_BUSY_ACTIVE_LEVEL)
    except Exception:
        log_exception("is_remote_device_active (GPIO.input)")
        return False

def parse_suffixes(cmd):
    valid_suffixes = {'I', 'R', 'P', 'M'}
    idx = len(cmd)
    suffixes = ""
    # Walk backwards until no more valid suffixes
    while idx > 0 and cmd[idx-1].upper() in valid_suffixes:
        suffixes = cmd[idx-1].upper() + suffixes
        idx -= 1
    return cmd[:idx], suffixes if suffixes else None

def parse_alternate_series(cmd):
    """
    Parse commands like:
      'P5985A5299I'
      'P5985A5299IM'
      'P1234A5678RM'
      'P1234A5678i5305'
    Returns:
      bases: list of int base codes (e.g., [5985, 5299])
      alt_suffix: str (e.g., 'IM', 'i5305', etc) or None
      is_alt: True if alternate syntax detected
    """
    import re
    cmd = cmd.strip()
    # Find all bases (PxxxxAyyyyAzzzz...)
    base_match = re.match(r'^P(\d{4})(A\d{4})+', cmd, re.IGNORECASE)
    if not base_match:
        return [], None, False

    # Extract all base codes
    bases = [int(base_match.group(1))]
    for match in re.finditer(r'A(\d{4})', cmd, re.IGNORECASE):
        bases.append(int(match.group(1)))

    # Remove all the bases from the command string to get the suffix part
    base_cmd = re.match(r'^(P\d{4}(A\d{4})+)', cmd, re.IGNORECASE).group(1)
    suffix_part = cmd[len(base_cmd):]
    alt_suffix = suffix_part if suffix_part else None
    return bases, alt_suffix, True

def get_base_type_and_info(base):
    for bases, ends, intervals, typ in [
        (random_bases, random_ends, random_intervals, 'Random'),
        (rotation_bases, rotation_ends, rotation_times, 'Rotation'),
        (sudo_bases, sudo_ends, sudo_intervals, 'SudoRandom')
    ]:
        if base in bases:
            idx = bases.index(base)
            end = ends[idx]
            interval = intervals[idx] * 60
            return typ, end, interval
    return None, None, None

def play_any_section_by_type(base, end, interval, typ, interruptible, repeat, pausing):
    if typ == "Random":
        play_randomized_section(base, end, interval, random_last_played, random_current_track, interruptible)
    elif typ == "Rotation":
        play_rotating_section(base, end, interval, rotation_last_played, rotation_current_track, interruptible)
    elif typ == "SudoRandom":
        play_sudo_random_section(base, end, interval, sudo_random_last_interval, sudo_random_interval_track, sudo_random_played_in_cycle, interruptible, repeat, pausing)
    else:
        play_direct_track(f"{base:04d}", interruptible, repeat, pausing)

def find_matching_files(base, end):
    files = []
    try:
        for track_num in range(base, end + 1):
            matching = [f for f in os.listdir(SOUND_DIRECTORY)
                        if match_code_file(f, f"{track_num:04d}", SOUND_FILE_EXTENSION)]
            files.extend([os.path.join(SOUND_DIRECTORY, f) for f in matching])
    except Exception:
        log_exception("find_matching_files")
    return files

def get_duration_wav(fname):
    try:
        with contextlib.closing(wave.open(fname, 'r')) as f:
            frames = f.getnframes()
            rate = f.getframerate()
            duration = frames / float(rate)
            return duration
    except Exception:
        log_exception("get_duration_wav")
        return 0

def launch_playback_thread(play_func, *args, **kwargs):
    global current_playback_thread, current_playback_token, playback_lock, playback_interrupt
    # Only keep keyword arguments that are real parameters of play_func (and not positional-only)
    sig = inspect.signature(play_func)
    allowed = {
        name for name, param in sig.parameters.items()
        if param.kind in (inspect.Parameter.KEYWORD_ONLY, inspect.Parameter.POSITIONAL_OR_KEYWORD)
    }
    kwargs = {k: v for k, v in kwargs.items() if k in allowed}
    with playback_lock:
        if current_playback_thread and current_playback_thread.is_alive():
            if threading.current_thread() is not current_playback_thread:
                playback_interrupt.set()
                current_playback_thread.join(timeout=2)
        playback_interrupt.clear()
        token = object()
        current_playback_token = token
        def wrapper():
            # Debug: print what is being called
            debug_log(f"Launching {play_func.__name__} with args={args} kwargs={kwargs}")
            kwargs['playback_token'] = token
            play_func(*args, **kwargs)
        t = threading.Thread(target=wrapper, daemon=True)
        current_playback_thread = t
        t.start()

def play_single_wav(code, interrupt_on_cos=False, block_interrupt=False, playback_token=None):
    """
    Play the wav for code or full filename; optionally interrupt if COS becomes active.
    Returns True if interrupted by COS, False if played to completion or interrupted by user.
    """
    import os

    global playback_status, currently_playing, currently_playing_info, currently_playing_info_timestamp

    # PATCH: If 'code' looks like a full path (endswith .wav and exists), use as filename directly
    if isinstance(code, str) and code.lower().endswith('.wav') and os.path.isfile(code):
        filename = code
    else:
        # Always match using match_code_file (handles dash-suffixes)
        matches = [
            f for f in os.listdir(SOUND_DIRECTORY)
            if match_code_file(f, code, SOUND_FILE_EXTENSION)
        ]
        if not matches:
            debug_log(f"File {code}{SOUND_FILE_EXTENSION} not found.")
            playback_status = "Idle"
            currently_playing = ""
            currently_playing_info = ""
            currently_playing_info_timestamp = 0
            return False
        filename = os.path.join(SOUND_DIRECTORY, matches[0])

    debug_log(f"play_single_wav: filename={filename}, interrupt_on_cos={interrupt_on_cos}, block_interrupt={block_interrupt}")
    try:
        proc = subprocess.Popen(['aplay', '-D', SOUND_DEVICE, filename], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except Exception as e:
        debug_log("Exception starting aplay:", e)
        playback_status = "Idle"
        currently_playing = ""
        currently_playing_info = ""
        currently_playing_info_timestamp = 0
        return False
    try:
        while proc.poll() is None:
            if playback_token is not None and playback_token != current_playback_token:
                proc.terminate()
                break
            if not block_interrupt and playback_interrupt.is_set():
                proc.terminate()
                break
            if interrupt_on_cos and is_cos_active():
                debug_log("COS became ACTIVE, interrupting playback")
                proc.terminate()
                time.sleep(0.1)
                if proc.poll() is None:
                    proc.kill()
                # Set Idle status after COS interrupt
                playback_status = "Idle"
                currently_playing = ""
                currently_playing_info = ""
                currently_playing_info_timestamp = 0
                return True
            time.sleep(0.05)
    finally:
        if proc.poll() is None:
            proc.kill()
        proc.wait()
        # Set Idle status after natural end or user interrupt
        playback_status = "Idle"
        currently_playing = ""
        currently_playing_info = ""
        currently_playing_info_timestamp = 0
    return False

def play_interrupt_to_another(base_filename, code2, playback_token=None):
    import os
    global currently_playing, currently_playing_info, currently_playing_info_timestamp
    global playback_status, playback_interrupt, current_playback_token
    debug_log(f"play_interrupt_to_another: base_filename={base_filename}, code2={code2}")

    base_name = os.path.splitext(os.path.basename(str(base_filename)))[0]
    code2_name = os.path.splitext(os.path.basename(str(code2)))[0]

    interrupted = False
    try:
        GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)
        if is_cos_active():
            # COS is already active: play code2 immediately
            currently_playing = f"{code2_name}"
            playback_status = f"Playing {code2_name} (COS active at start)"
            currently_playing_info = f"Playing {code2_name} (COS active at start)"
            currently_playing_info_timestamp = time.time()
            play_single_wav(code2, block_interrupt=True, playback_token=playback_token)
            log_recent(f"Interrupt: COS active at start, played {code2_name} directly")
        else:
            # Playing base_filename, with potential to interrupt to code2 if COS activates
            currently_playing = base_name
            playback_status = f"Playing {base_name}, will interrupt to {code2_name} on COS"
            currently_playing_info = f"Playing {base_name} (will interrupt to {code2_name} if COS)"
            currently_playing_info_timestamp = time.time()
            interrupted = play_single_wav(base_filename, interrupt_on_cos=True, playback_token=playback_token)
            if interrupted:
                currently_playing = f"{code2_name}"
                playback_status = f"Playing {code2_name} (interrupted from {base_name})"
                currently_playing_info = f"Interrupted {base_name}, now playing {code2_name}"
                currently_playing_info_timestamp = time.time()
                play_single_wav(code2, block_interrupt=True, playback_token=playback_token)
                log_recent(f"Interrupt: {base_name} interrupted by COS, switched to {code2_name}")
            else:
                log_recent(f"Interrupt: {base_name} played without COS, did not switch to {code2_name}")
    finally:
        GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
        playback_status = "Idle"
        currently_playing = ""
        currently_playing_info = ""
        currently_playing_info_timestamp = 0

def play_randomized_section(base, end, interval, last_played_dict, current_track_dict, interruptible=False, repeating=False, pausing=False):
    try:
        current_time = time.time()
        last_played = last_played_dict.get(base, 0)
        current_track = current_track_dict.get(base, None)
        matching_files = find_matching_files(base, end)
        if not matching_files:
            return
        if current_time - last_played >= interval or current_track not in matching_files:
            new_track = random.choice(matching_files)
            current_track_dict[base] = new_track
            last_played_dict[base] = current_time
        else:
            new_track = current_track
        threading.Thread(
            target=play_sound,
            args=(new_track, interruptible, pausing, repeating)
        ).start()
    except Exception:
        log_exception("play_randomized_section")

def play_rotating_section(base, end, interval, last_played_dict, current_track_dict, interruptible=False, repeat=False, pausing=False):
    try:
        current_time = time.time()
        last_played = last_played_dict.get(base, 0)
        # Build a list of (track_num, filename) for all present files in the range
        available_tracks = []
        for track_num in range(base + 1, end + 1):
            for f in os.listdir(SOUND_DIRECTORY):
                if match_code_file(f, f"{track_num:04d}", SOUND_FILE_EXTENSION):
                    available_tracks.append((track_num, f))
                    break  # Only take the first matching file for each number

        if not available_tracks:
            return

        # Get just the numbers for rotating
        available_nums = [num for num, _ in available_tracks]

        if base not in current_track_dict or current_track_dict[base] not in available_nums:
            current_track_num = available_nums[0]
        else:
            current_track_num = current_track_dict[base]

        if last_played == 0:
            next_track_idx = available_nums.index(current_track_num)
            last_played_dict[base] = current_time
        elif current_time - last_played >= interval:
            idx = available_nums.index(current_track_num)
            next_track_idx = (idx + 1) % len(available_nums)
            last_played_dict[base] = current_time
        else:
            next_track_idx = available_nums.index(current_track_num)

        next_track_num, next_file = available_tracks[next_track_idx]
        current_track_dict[base] = next_track_num
        next_track = os.path.join(SOUND_DIRECTORY, next_file)
        threading.Thread(
            target=play_sound,
            args=(next_track, interruptible, pausing, repeat),  # <-- pausing then repeat
        ).start()
        rotation_active[base] = False
    except Exception:
        log_exception("play_rotating_section")
        rotation_active[base] = False

def play_sudo_random_section(base, end, interval, last_interval_dict, interval_track_dict, played_in_cycle_dict, interruptible=False, repeat=False, pausing=False):
    global sudo_random_last_file
    current_time = time.time()
    matching_files = find_matching_files(base, end)
    if not matching_files:
        return
    last_interval = last_interval_dict.get(base, 0)
    current_track = interval_track_dict.get(base)
    played_in_cycle = played_in_cycle_dict.get(base, set())
    if current_track is not None and (current_time - last_interval < interval) and current_track in matching_files:
        file_to_play = current_track
    else:
        unused_tracks = [t for t in matching_files if t not in played_in_cycle]
        if not unused_tracks:
            played_in_cycle = set()
            unused_tracks = matching_files[:]
        new_track = random.choice(unused_tracks)
        file_to_play = new_track
        interval_track_dict[base] = file_to_play
        last_interval_dict[base] = current_time
        played_in_cycle.add(file_to_play)
        played_in_cycle_dict[base] = played_in_cycle
    sudo_random_last_file[base] = file_to_play
    threading.Thread(target=play_sound, args=(file_to_play, interruptible, pausing, repeat)).start()

def play_direct_track(code_str, interruptible=False, pausing=False, repeat=False):
    debug_log(f"play_direct_track: code_str={code_str}")
    files = os.listdir(SOUND_DIRECTORY)
    debug_log(f"Directory listing: {files}")
    matches = [f for f in files if match_code_file(f, code_str, SOUND_FILE_EXTENSION)]
    debug_log(f"Matching files for code_str={code_str}: {matches}")
    if matches:
        filename = os.path.join(SOUND_DIRECTORY, matches[0])
        debug_log(f"Playing file: {filename}")
        threading.Thread(target=play_sound, args=(filename, interruptible, pausing, repeat)).start()
    else:
        debug_log(f"Play (serial/auto): {code_str} - failed -> file not found")
        # Use code_str instead of filename here, since filename may not be defined
        log_recent(f"Play (serial/auto): {code_str} - failed -> file not found")

def play_code(code_str, interruptible=False, pausing=False, repeating=False):
    debug_log(f"play_code: code_str={code_str}")
    files = os.listdir(SOUND_DIRECTORY)
    debug_log(f"play_code: Directory listing: {files}")
    matches = [f for f in files if match_code_file(f, code_str, SOUND_FILE_EXTENSION)]
    debug_log(f"play_code: Matching files for code_str={code_str}: {matches}")
    if matches:
        filename = os.path.join(SOUND_DIRECTORY, matches[0])
        debug_log(f"play_code: Launching playback for {filename}")
        launch_playback_thread(
            play_sound,
            filename=filename,
            interruptible=interruptible,
            pausing=pausing,
            repeating=repeating
        )
    else:
        debug_log(f"play_code: No sound file found for code_str={code_str}")

def parse_serial_command(command):
    """
    Accepts:
      - Pxxxx
      - PxxxxI, PxxxxP, PxxxxR, PxxxxM, PxxxxIM, PxxxxRM, etc.
      - PxxxxiYYYY (interrupt-to-another), ignoring any suffix after second code
    Returns:
      (base: str, suffix: str or None, interrupt_to: str or None)
    """
    command = command.strip().upper()
    # Handle interrupt-to-another, e.g. P1234I5678 or P1234i5678
    m = re.match(r'^P(\d{4})I(\d{4})', command)
    if not m:
        m = re.match(r'^P(\d{4})i(\d{4})', command)
    if m:
        return (m.group(1), "i", m.group(2))

    # Handle all other suffix forms using parse_suffixes
    m = re.match(r'^P(\d{4})(.*)$', command)
    if m:
        base = m.group(1)
        suffix = m.group(2)
        # Use your parse_suffixes to extract valid trailing suffixes (I, P, R, M)
        base2, suffixes = parse_suffixes(f"{base}{suffix}")
        # base2 should be base, suffixes is a string of valid suffix chars or None
        return (base2, suffixes, None)

    return (None, None, None)

def auto_alternate_series(command, interval_per_base=60):
    # interval_per_base should match your config for [Rotation] time in seconds
    # If you want to read the real interval for each base from your config, you can do so.
    bases, _, is_alt = parse_alternate_series(command)
    if not is_alt or not bases:
        debug_log("Not a valid alternate series command.")
        return

    key = tuple(sorted(bases))
    pointer = 0

    while True:
        current_base = bases[pointer]
        process_command(command)
        debug_log(f"Played base {current_base}, waiting {interval_per_base} seconds before next base...")
        time.sleep(interval_per_base)
        pointer = (pointer + 1) % len(bases)

def get_next_base_file(base_code):
    typ, end, interval = get_base_type_and_info(base_code)
    if typ == "Rotation":
        available_tracks = []
        for track_num in range(base_code + 1, end + 1):
            for f in os.listdir(SOUND_DIRECTORY):
                if match_code_file(f, f"{track_num:04d}", SOUND_FILE_EXTENSION):
                    available_tracks.append((track_num, f))
                    break
        if not available_tracks:
            return None
        available_nums = [num for num, _ in available_tracks]
        current_num = rotation_current_track.get(base_code, available_nums[0])
        if current_num not in available_nums:
            current_num = available_nums[0]
        idx = available_nums.index(current_num)
        now = time.time()
        last_played = rotation_last_played.get(base_code, 0)
        if last_played == 0:
            next_idx = idx
            rotation_last_played[base_code] = now
        elif now - last_played >= interval:
            next_idx = (idx + 1) % len(available_nums)
            rotation_last_played[base_code] = now
        else:
            next_idx = idx
        rotation_current_track[base_code] = available_nums[next_idx]
        return os.path.join(SOUND_DIRECTORY, available_tracks[next_idx][1])
    elif typ == "Random":
        matching_files = find_matching_files(base_code, end)
        if not matching_files:
            return None
        last_played = random_last_played.get(base_code, 0)
        current_track = random_current_track.get(base_code, None)
        now = time.time()
        if now - last_played >= interval or current_track not in matching_files:
            chosen = random.choice(matching_files)
            random_current_track[base_code] = chosen
            random_last_played[base_code] = now
            return chosen
        else:
            return current_track
    elif typ == "SudoRandom":
        matching_files = find_matching_files(base_code, end)
        if not matching_files:
            return None
        played_in_cycle = sudo_random_played_in_cycle.get(base_code, set())
        if not isinstance(played_in_cycle, set):
            played_in_cycle = set(played_in_cycle)
        unused_tracks = [t for t in matching_files if t not in played_in_cycle]
        if not unused_tracks:
            played_in_cycle = set()
            unused_tracks = matching_files[:]
        chosen = random.choice(unused_tracks)
        sudo_random_interval_track[base_code] = chosen
        sudo_random_last_interval[base_code] = time.time()
        played_in_cycle.add(chosen)
        sudo_random_played_in_cycle[base_code] = played_in_cycle
        return chosen
    else:
        # PATCH: match dash-suffixed files for direct (non-section) case
        files = os.listdir(SOUND_DIRECTORY)
        matches = [f for f in files if match_code_file(f, f"P{base_code}", SOUND_FILE_EXTENSION)]
        if matches:
            return os.path.join(SOUND_DIRECTORY, matches[0])
        return None

def should_allow_message_timer_play(message_mode, timer_value, last_played):
    """
    Returns True if playback should be allowed for message-timer-locked playback.
    - timer_value: in minutes (can be 0, 'N', or a number)
    - last_played: timestamp of last allowed message playback
    """
    if not message_mode or timer_value is None:
        return True
    if timer_value == 'N':
        return False
    if timer_value == 0:
        return True
    now = time.time()
    if last_played is not None and now - last_played < timer_value * 60:
        return False
    return True

def update_message_timer_state(last_played, interval):
    try:
        with open(STATE_FILE, 'r') as f:
            state = json.load(f)
    except Exception:
        state = {}
    state['message_timer_last_played'] = last_played
    state['message_timer_value'] = interval
    with open(STATE_FILE, 'w') as f:
        json.dump(state, f)

def process_command(command):
    global playback_interrupt, currently_playing, currently_playing_info, currently_playing_info_timestamp, playback_status
    global message_timer_last_played, message_timer_value

    debug_log("process_command reached")
    debug_log(f"RAW process_command input: {repr(command)}")
    try:
        playback_interrupt.set()
        time.sleep(0.1)
        playback_interrupt.clear()

        # --- Play by filename if .wav ---
        if command.lower().endswith('.wav'):
            filename = os.path.join(SOUND_DIRECTORY, command)
            if os.path.isfile(filename):
                launch_playback_thread(play_sound, filename=filename)
                playback_status = f"Direct: {command}"
                currently_playing = command
                currently_playing_info = f"Direct playback of {command}"
                currently_playing_info_timestamp = time.time()
            else:
                playback_status = "Idle"
                currently_playing = ""
                currently_playing_info = ""
                currently_playing_info_timestamp = 0
            write_state()
            return

        # --- Alternate series logic ---
        bases, alt_suffix, is_alt = parse_alternate_series(command.strip())
        debug_log(f"parse_alternate_series: bases={bases}, alt_suffix={alt_suffix}, is_alt={is_alt}")
        if is_alt and bases:
            cosi_interrupt_code = None
            if alt_suffix and alt_suffix.lower().startswith('i') and len(alt_suffix) > 1 and alt_suffix[1:].isdigit():
                cosi_interrupt_code = alt_suffix[1:]
            suffix = alt_suffix.upper() if alt_suffix else ""
            interruptible = "I" in suffix
            repeat = "R" in suffix
            pausing = "P" in suffix
            message_mode = "M" in suffix

            should_play_message = should_allow_message_timer_play(message_mode, message_timer_value, message_timer_last_played)
            if message_mode and not should_play_message:
                playback_status = "Message Timer is Running or Disabled!"
                currently_playing = ""
                currently_playing_info = ""
                currently_playing_info_timestamp = time.time()
                write_state()
                return

            if message_mode and should_play_message:
                message_timer_last_played = time.time()

            key = tuple(sorted(bases))
            if key not in alternate_series_pointers:
                alternate_series_pointers[key] = 0
            pointer = alternate_series_pointers[key]
            start_pointer = pointer
            played = False
            for step in range(len(bases)):
                base = bases[pointer]
                base_filename = get_next_base_file(base)
                if base_filename:
                    now = time.time()
                    if key not in alternate_series_last_played:
                        alternate_series_last_played[key] = {b: 0 for b in bases}
                    if key not in alternate_series_track_pointers:
                        alternate_series_track_pointers[key] = {}
                    alternate_series_last_played[key][base] = now
                    alternate_series_track_pointers[key][base] = os.path.basename(base_filename)
                    if cosi_interrupt_code:
                        launch_playback_thread(
                            play_interrupt_to_another,
                            base_filename, str(cosi_interrupt_code)
                        )
                    else:
                        launch_playback_thread(
                            play_sound,
                            filename=base_filename,
                            interruptible=interruptible,
                            pausing=pausing,
                            repeating=repeat
                        )
                    played = True
                    alternate_series_pointers[key] = (pointer + 1) % len(bases)
                    write_state()
                    return
                pointer = (pointer + 1) % len(bases)
                if pointer == start_pointer:
                    break
            if not played:
                alternate_series_pointers[key] = pointer
            write_state()
            return

        # --- Serial (direct) and section logic ---
        code_str, suffix, alt_code = parse_serial_command(command.strip())
        if code_str is None:
            playback_status = "Idle"
            currently_playing = ""
            currently_playing_info = ""
            currently_playing_info_timestamp = 0
            write_state()
            return

        suffix = suffix.upper() if suffix else ""
        interruptible = "I" in suffix
        repeat = "R" in suffix
        pausing = "P" in suffix
        message_mode = "M" in suffix
        code = int(code_str)

        should_play_message = should_allow_message_timer_play(message_mode, message_timer_value, message_timer_last_played)
        if message_mode and not should_play_message:
            playback_status = "Message Timer is Running or Disabled!"
            currently_playing = ""
            currently_playing_info = ""
            currently_playing_info_timestamp = time.time()
            write_state()
            return

        if message_mode and should_play_message:
            message_timer_last_played = time.time()

        # COS-i logic (interrupt to another code)
        if suffix == 'I' and alt_code is not None:
            base_filename = get_next_base_file(code)
            if not base_filename:
                playback_status = "Idle"
                currently_playing = ""
                currently_playing_info = ""
                currently_playing_info_timestamp = 0
                write_state()
                return
            launch_playback_thread(
                play_interrupt_to_another,
                base_filename, str(alt_code)
            )
            playback_status = f"Interrupt: {code} -> {alt_code}"
            currently_playing = f"{code} -> {alt_code}"
            currently_playing_info = f"Interrupt playback from {code} to {alt_code}"
            currently_playing_info_timestamp = time.time()
            write_state()
            return

        # Random Section
        for b, e, t in zip(random_bases, random_ends, random_intervals):
            if code == b:
                play_randomized_section(b, e, t * 60, random_last_played, random_current_track, interruptible, pausing, repeat)
                track_file = random_current_track.get(b)
                if track_file:
                    track_num = os.path.splitext(os.path.basename(track_file))[0]
                    currently_playing = f"{track_num} from Random Base starting at {b}"
                    currently_playing_info = f"{track_num} from Random Base starting at {b}"
                else:
                    currently_playing = f"Random section starting at {b}"
                    currently_playing_info = f"Randomized section {b}-{e}"
                playback_status = f"Random: {b}"
                currently_playing_info_timestamp = time.time()
                write_state()
                return
            elif b < code <= e:
                play_direct_track(code_str, interruptible, pausing, repeat)
                write_state()
                return

        # Rotating Section
        for b, e, t in zip(rotation_bases, rotation_ends, rotation_times):
            if code == b:
                if not rotation_active.get(b, False):
                    rotation_active[b] = True
                    play_rotating_section(b, e, t * 60, rotation_last_played, rotation_current_track, interruptible, pausing, repeat)
                    track_num = rotation_current_track.get(b, b+1)
                    currently_playing = f"{track_num} from Rotating Base starting at {b}"
                    currently_playing_info = f"{track_num} from Rotating Base starting at {b}"
                    playback_status = f"Rotating: {b}"
                    currently_playing_info_timestamp = time.time()
                else:
                    debug_log(f"Rotation for base {b} is already active, ignoring repeat trigger.")
                write_state()
                return
            elif b < code <= e:
                play_direct_track(code_str, interruptible, pausing, repeat)
                write_state()
                return

        # SudoRandom Section
        for b, e, t in zip(sudo_bases, sudo_ends, sudo_intervals):
            if code == b:
                play_sudo_random_section(
                    b, e, t * 60,
                    sudo_random_last_interval,
                    sudo_random_interval_track,
                    sudo_random_played_in_cycle,
                    interruptible, pausing, repeat
                )
                track_file = sudo_random_interval_track.get(b)
                if track_file:
                    track_num = os.path.splitext(os.path.basename(track_file))[0]
                    currently_playing = f"{track_num} from SudoRandom Base starting at {b}"
                    currently_playing_info = f"{track_num} from SudoRandom Base starting at {b}"
                else:
                    currently_playing = f"SudoRandom section starting at {b}"
                    currently_playing_info = f"SudoRandom section {b}-{e}"
                playback_status = f"SudoRandom: {b}"
                currently_playing_info_timestamp = time.time()
                write_state()
                return
            elif b < code <= e:
                play_direct_track(code_str, interruptible, pausing, repeat)
                write_state()
                return

        # Direct section (default)
        if DIRECT_ENABLED:
            play_direct_track(code_str, interruptible, pausing, repeat)
            playback_status = f"Direct: {code_str}"
            currently_playing = code_str
            currently_playing_info = f"Direct playback of {code_str}"
            currently_playing_info_timestamp = time.time()
        else:
            playback_status = "Idle"
            currently_playing = ""
            currently_playing_info = ""
            currently_playing_info_timestamp = 0
        write_state()
    except Exception:
        log_exception("process_command")

def write_state():
    now = time.time()

    # Read previous state from disk to get last_played and previous currently_playing
    prev_state = {}
    if os.path.exists(STATE_FILE):
        try:
            with open(STATE_FILE, 'r') as f:
                prev_state = json.load(f)
        except Exception:
            prev_state = {}

    prev_current = prev_state.get("currently_playing", "")
    prev_last = prev_state.get("last_played", "")

    # Decide what last_played should be for this write
    if (
        prev_current
        and prev_current.lower() != "idle"
        and prev_current != currently_playing
    ):
        last_played = prev_current
    else:
        last_played = prev_last

    # Random bases lines
    random_bases_lines = []
    for b, e, t in zip(random_bases, random_ends, random_intervals):
        last = random_last_played.get(b, 0)
        current = random_current_track.get(b, 'N/A')
        remaining = int(max(0, t*60 - (now - last)))
        if not current or str(current).upper() == "N/A":
            track_name = "N/A"
        else:
            track_name = os.path.splitext(os.path.basename(current))[0]
        random_bases_lines.append(
            f"Base {b} | End {e} Interval {t}: Track={track_name} Remaining={remaining}s"
        )

    # Rotation bases lines
    rotation_bases_lines = []
    for b, e, t in zip(rotation_bases, rotation_ends, rotation_times):
        last = rotation_last_played.get(b, 0)
        current_num = rotation_current_track.get(b, b+1)
        remaining = int(max(0, t*60 - (now - last)))
        rotation_bases_lines.append(
            f"Base {b} | End {e} Interval {t}: Track={current_num} Remaining={remaining}s"
        )

    # SudoRandom bases lines
    sudo_bases_lines = []
    for b, e, t in zip(sudo_bases, sudo_ends, sudo_intervals):
        last = sudo_random_last_interval.get(b, 0)
        current = sudo_random_interval_track.get(b, 'N/A')
        played = sudo_random_played_in_cycle.get(b, set())
        remaining = int(max(0, t*60 - (now - last)))
        if not current or str(current).upper() == "N/A":
            track_name = "N/A"
        else:
            track_name = os.path.splitext(os.path.basename(current))[0]
        sudo_bases_lines.append(
            f"Base {b} | End {e} Interval {t}: Track={track_name} Remaining={remaining}s PlayedInCycle={len(played)}"
        )

    # --- ALT SERIES STATE (NEW) ---
    alt_bases_lines = []
    for key, last_played_dict in alternate_series_last_played.items():
        bases = list(key)
        pointer = alternate_series_pointers.get(key, 0)
        track_pointers = alternate_series_track_pointers.get(key, {})
        for base in bases:
            typ, end, interval = get_base_type_and_info(base)
            last = last_played_dict.get(base, 0)
            remaining = int(max(0, interval - (now - last))) if interval else 0
            track_val = track_pointers.get(base, 1)
            if typ == 'Rotation':
                current_num = base + (track_val if isinstance(track_val, int) else 1)
                track_display = str(current_num)
            else:
                if track_val and isinstance(track_val, str) and track_val.upper() != "N/A":
                    track_display = os.path.splitext(os.path.basename(track_val))[0]
                else:
                    track_display = str(current_num)
            alt_bases_lines.append(
                f"Series {key} Base {base} Type {typ} | End {end} Interval {interval//60 if interval else 0}m: Track={track_display} Remaining={remaining}s"
            )

    # --- MESSAGE TIMER REMAINING CALCULATION ---
    if message_timer_last_played and message_timer_value:
        message_timer_remaining = max(0, message_timer_value * 60 - (now - message_timer_last_played))
    else:
        message_timer_remaining = 0

    state = {
        "currently_playing": currently_playing,
        "currently_playing_info": currently_playing_info,
        "currently_playing_info_timestamp": currently_playing_info_timestamp,
        "playing_end_time": playing_end_time,
        "playback_status": playback_status,
        "serial_port_missing": serial_port_missing,
        "sound_card_missing": sound_card_missing,
        "serial_history": serial_history[-10:],
        "cos_active": is_cos_active(),
        "remote_device_active": is_remote_device_active(),
        "uptime": get_drx_uptime(),

        "random_last_played": {b: random_last_played.get(b, 0) for b in random_bases},
        "random_current_track": {b: os.path.basename(random_current_track.get(b, "")) if random_current_track.get(b, "") else "N/A" for b in random_bases},

        "rotation_last_played": {b: rotation_last_played.get(b, 0) for b in rotation_bases},
        "rotation_current_track": {b: rotation_current_track.get(b, b+1) for b in rotation_bases},

        "sudo_random_last_interval": {b: sudo_random_last_interval.get(b, 0) for b in sudo_bases},
        "sudo_random_interval_track": {b: os.path.basename(sudo_random_interval_track.get(b, "")) if sudo_random_interval_track.get(b, "") else "N/A" for b in sudo_bases},
        "sudo_random_played_in_cycle": {b: [os.path.basename(x) for x in sudo_random_played_in_cycle.get(b, set())] for b in sudo_bases},

        "random_bases_lines": random_bases_lines,
        "rotation_bases_lines": rotation_bases_lines,
        "sudo_bases_lines": sudo_bases_lines,
        "alt_bases_lines": alt_bases_lines,

        "drx_start_time": DRX_START_TIME,
        "updated_at": now,
        "last_played": last_played,

        # --- MESSAGE TIMER FIELDS ---
        "message_timer_last_played": message_timer_last_played,
        "message_timer_value": message_timer_value,
        "message_timer_remaining": int(message_timer_remaining)
    }
    try:
        debug_log(f"write_state() called with: {state}")
        with open(STATE_FILE, 'w') as f:
            json.dump(state, f)
    except Exception as e:
        debug_log(f"write_state() exception: {e}")

def reload_config():
    global config, SOUND_DIRECTORY, SOUND_FILE_EXTENSION, SOUND_DEVICE
    global COS_PIN, COS_ACTIVE_LEVEL, REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL, COS_DEBOUNCE_TIME, MAX_COS_INTERRUPTIONS
    global SERIAL_PORT, SERIAL_BAUDRATE, SERIAL_TIMEOUT
    global RANDOM_BASE, RANDOM_END, RANDOM_INTERVAL, ROTATION_BASE, ROTATION_END, ROTATION_TIME
    global SUDORANDOM_BASE, SUDORANDOM_END, SUDORANDOM_INTERVAL, DIRECT_ENABLED, DIRECT_PREFIX
    global random_bases, random_ends, random_intervals, rotation_bases, rotation_ends, rotation_times
    global sudo_bases, sudo_ends, sudo_intervals
    global message_timer_value

    config.read(config_file_path)
    SOUND_DIRECTORY = get_config_value("Sound", "directory", DEFAULTS["Sound"]["directory"])
    SOUND_FILE_EXTENSION = get_config_value("Sound", "extension", DEFAULTS["Sound"]["extension"])
    SOUND_DEVICE = get_config_value("Sound", "device", DEFAULTS["Sound"]["device"])

    COS_PIN = get_config_value("GPIO", "cos_pin", DEFAULTS["GPIO"]["cos_pin"], int)
    COS_ACTIVE_LEVEL = get_config_value("GPIO", "cos_activate_level", DEFAULTS["GPIO"]["cos_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
    REMOTE_BUSY_PIN = get_config_value("GPIO", "remote_busy_pin", DEFAULTS["GPIO"]["remote_busy_pin"], int)
    REMOTE_BUSY_ACTIVE_LEVEL = get_config_value("GPIO", "remote_busy_activate_level", DEFAULTS["GPIO"]["remote_busy_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
    COS_DEBOUNCE_TIME = get_config_value("GPIO", "cos_debounce_time", DEFAULTS["GPIO"]["cos_debounce_time"], float)
    MAX_COS_INTERRUPTIONS = get_config_value("GPIO", "max_cos_interruptions", DEFAULTS["GPIO"]["max_cos_interruptions"], int)

    SERIAL_PORT = get_config_value("Serial", "port", DEFAULTS["Serial"]["port"])
    SERIAL_BAUDRATE = get_config_value("Serial", "baudrate", DEFAULTS["Serial"]["baudrate"], int)
    SERIAL_TIMEOUT = get_config_value("Serial", "timeout", DEFAULTS["Serial"]["timeout"], float)

    RANDOM_BASE = get_config_value("Random", "base", DEFAULTS["Random"]["base"])
    RANDOM_END = get_config_value("Random", "end", DEFAULTS["Random"]["end"])
    RANDOM_INTERVAL = get_config_value("Random", "interval", DEFAULTS["Random"]["interval"])
    ROTATION_BASE = get_config_value("Rotation", "base", DEFAULTS["Rotation"]["base"])
    ROTATION_END = get_config_value("Rotation", "end", DEFAULTS["Rotation"]["end"])
    ROTATION_TIME = get_config_value("Rotation", "interval", DEFAULTS["Rotation"]["interval"])
    SUDORANDOM_BASE = get_config_value("SudoRandom", "base", DEFAULTS["SudoRandom"]["base"])
    SUDORANDOM_END = get_config_value("SudoRandom", "end", DEFAULTS["SudoRandom"]["end"])
    SUDORANDOM_INTERVAL = get_config_value("SudoRandom", "interval", DEFAULTS["SudoRandom"]["interval"])
    DIRECT_ENABLED = get_config_value("Direct", "enabled", DEFAULTS["Direct"]["enabled"], lambda x: str(x).lower() in ("1", "true", "yes"))
    DIRECT_PREFIX = get_config_value("Direct", "prefix", DEFAULTS["Direct"]["prefix"])

    random_bases[:] = parse_int_list(RANDOM_BASE, fallback=3000, label="Random base", section="Random")
    random_ends[:] = parse_int_list(RANDOM_END, fallback=3099, label="Random end", section="Random")
    random_intervals[:] = parse_float_list(RANDOM_INTERVAL, fallback=10, label="Random interval", section="Random")
    rotation_bases[:] = parse_int_list(ROTATION_BASE, fallback=4000, label="Rotation base", section="Rotation")
    rotation_ends[:] = parse_int_list(ROTATION_END, fallback=4099, label="Rotation end", section="Rotation")
    rotation_times[:] = parse_float_list(ROTATION_TIME, fallback=10, label="Rotation time", section="Rotation")
    sudo_bases[:] = parse_int_list(SUDORANDOM_BASE, fallback=5000, label="SudoRandom base", section="SudoRandom")
    sudo_ends[:] = parse_int_list(SUDORANDOM_END, fallback=5099, label="SudoRandom end", section="SudoRandom")
    sudo_intervals[:] = parse_float_list(SUDORANDOM_INTERVAL, fallback=10, label="SudoRandom interval", section="SudoRandom")

    message_timer_value = parse_message_timer(get_config_value("General", "Message Timer", "N"))

    validate_config_pairs()

def maybe_run_webcmd():
    if os.path.exists(WEBCMD_FILE):
        try:
            with open(WEBCMD_FILE, 'r') as f:
                cmd = json.load(f)
            if cmd.get("type") == "play":
                input_cmd = cmd.get("input", "").strip()
                if input_cmd.lower().endswith('.wav'):
                    source = "web dropdown"
                else:
                    source = "web input box"
                try:
                    serial_out = process_command(input_cmd)
                    log_recent(f"Play requested: {input_cmd} ({source})")
                    # --- Update global and state serial_history ---
                    global serial_history
                    serial_history.insert(0, {
                        "cmd": f"> {input_cmd}",
                        "ts": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        "src": "Web"
                    })
                    if serial_out:
                        serial_history.insert(0, {
                            "cmd": str(serial_out),
                            "ts": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            "src": "Web"
                        })
                    serial_history = serial_history[:10]
                    # Update state file
                    state = read_state()
                    state['serial_history'] = serial_history
                    with open(STATE_FILE, 'w') as sf:
                        json.dump(state, sf)
                except Exception as e:
                    log_recent(f"Play requested: {input_cmd} ({source}) - failed -> {e}")
            elif cmd.get("type") == "stop":
                playback_interrupt.set()
                playback_status = "Idle"
                currently_playing = "" 
                log_recent("Playback stopped from web")
            elif cmd.get("type") == "reload_config":
                reload_config()
                log_recent("Configuration reload requested from web")
            elif cmd.get("type") == "restart":
                log_recent("DRX script restart requested from web")
                os.remove(WEBCMD_FILE)
                os.execv(sys.executable, [sys.executable] + sys.argv)
                return
            elif cmd.get("type") == "reboot":
                log_recent("System reboot requested from web")
                os.remove(WEBCMD_FILE)
                os.system("reboot")
                return
            os.remove(WEBCMD_FILE)
        except Exception:
            log_exception("maybe_run_webcmd")

def serial_read_loop():
    global serial_buffer, serial_history
    try:
        serial_port = serial.Serial(
            port=SERIAL_PORT,
            baudrate=SERIAL_BAUDRATE,
            timeout=SERIAL_TIMEOUT
        )
        serial_port.reset_input_buffer()
    except Exception as e:
        debug_log(f"Serial exception: {e}")
        serial_port = None
    while True:
        try:
            if serial_port and serial_port.in_waiting:
                data = serial_port.read(serial_port.in_waiting)
                try:
                    decoded = data.decode('ascii', errors='ignore')
                    cleaned = ''.join(c for c in decoded if c.isprintable())
                    serial_buffer += cleaned  # Only text for curses!
                    # Optional: debug print for troubleshooting
                    debug_log(f"serial_buffer updated: {repr(serial_buffer[-100:])}")  # Show last 100 chars

                    for line in cleaned.splitlines():
                        if line.strip():
                            serial_history.insert(0, {
                                "cmd": line.strip(),
                                "ts": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                                "src": "Serial"
                            })
                            if len(serial_history) > 10:
                                serial_history.pop()
                except UnicodeDecodeError as e:
                    debug_log(f"Unicode error: {e}")
        except Exception as e:
            debug_log(f"Loop exception: {e}")
        time.sleep(0.05)

def process_serial_commands():
    """
    Continuously scan the serial_buffer for valid command patterns.
    Supports:
      - Pxxxx
      - PxxxxI
      - PxxxxP
      - PxxxxR
      - PxxxxM, PxxxxIM, PxxxxRM, etc.
      - PxxxxiYYYY (interrupt-to-another), ignoring any suffix after second code
      - PddddAeeee... (alternate/series), with or without suffixes
    """
    global serial_buffer
    # Pattern supports series (PddddAeeee...), interrupt-to-another, and all multi-suffix combos
    pattern = r'P\d{4}(?:A\d{4})*(I\d{4}|i\d{4}|[IPRM]*)'

    while True:
        try:
            # Use .upper() for matching but operate on the actual buffer for removal
            match = re.search(pattern, serial_buffer.upper())
            if match:
                command = match.group(0)
                debug_log(f"Processing command: '{command}'")
                process_command(command)
                # Remove only the first occurrence, strip leading whitespace
                index = serial_buffer.upper().find(command)
                if index != -1:
                    serial_buffer = serial_buffer[:index] + serial_buffer[index+len(command):]
                serial_buffer = serial_buffer.lstrip()
                debug_log(f"serial_buffer after removal: '{serial_buffer}'")
            time.sleep(0.1)
        except Exception as e:
            debug_log(f"Exception in process_serial_commands: {e}")
            pass

def status_screen(stdscr):
    global serial_buffer, serial_history, currently_playing, currently_playing_info
    global currently_playing_info_timestamp, playing_end_time, playback_status
    global serial_port_missing, sound_card_missing
    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_BLACK)
    curses.init_pair(6, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(7, curses.COLOR_MAGENTA, curses.COLOR_BLACK)  # For remote device active
    curses.curs_set(0)
    stdscr.nodelay(True)
    flash_state = itertools.cycle([True, False])
    while True:
        try:
            stdscr.erase()
            y = 0
            warning_msgs = []
            if serial_port_missing:
                warning_msgs.append("SERIAL PORT NOT FOUND")
            if sound_card_missing:
                warning_msgs.append("SOUND CARD/DEVICE NOT FOUND")
            if config_warnings and next(flash_state):
                warning_msgs.extend(config_warnings)
            if warning_msgs:
                for line in warning_msgs:
                    stdscr.addstr(y, 0, line, curses.color_pair(6) | curses.A_BOLD)
                    y += 1
            stdscr.addstr(y, 0, f"{SCRIPT_NAME} v{VERSION} - Status Screen", curses.color_pair(1))
            y += 1
            y += 1
            stdscr.addstr(y, 0, "Rotation Bases State:", curses.color_pair(2))
            y += 1
            for b, e, t in zip(rotation_bases, rotation_ends, rotation_times):
                last = rotation_last_played.get(b, 0)
                current_num = rotation_current_track.get(b, b+1)
                remaining = max(0, t*60 - (time.time() - last))
                stdscr.addstr(y, 0, f"Base {b} | End {e} Interval {t}: Track={current_num} Remaining={remaining:.1f}s", curses.color_pair(3))
                y += 1
            y += 1
            stdscr.addstr(y, 0, "Random Bases State:", curses.color_pair(2))
            y += 1
            for b, e, t in zip(random_bases, random_ends, random_intervals):
                last = random_last_played.get(b, 0)
                current = random_current_track.get(b, 'N/A')
                remaining = max(0, t*60 - (time.time() - last))
                track_name = os.path.basename(current) if current != 'N/A' and current else 'N/A'
                stdscr.addstr(y, 0, f"Base {b} | End {e} Interval {t}: Track={track_name} Remaining={remaining:.1f}s", curses.color_pair(3))
                y += 1
            y += 1
            stdscr.addstr(y, 0, "SudoRandom Bases State:", curses.color_pair(2))
            y += 1
            for b, e, t in zip(sudo_bases, sudo_ends, sudo_intervals):
                last = sudo_random_last_interval.get(b, 0)
                current = sudo_random_interval_track.get(b, 'N/A')
                played = sudo_random_played_in_cycle.get(b, set())
                remaining = max(0, t*60 - (time.time() - last))
                track_name = os.path.basename(current) if current != 'N/A' and current else 'N/A'
                stdscr.addstr(y, 0, f"Base {b} | End {e} Interval {t}: Track={track_name} Remaining={remaining:.1f}s PlayedInCycle={len(played)}", curses.color_pair(3))
                y += 1
            y += 1
            stdscr.move(y, 0)
            stdscr.clrtoeol()
            # Show last 5 serial_history entries by extracting the "cmd" field:
            serial_display = ' | '.join(
                ''.join(c for c in (s["cmd"] if isinstance(s, dict) else str(s)) if c in string.printable and c not in '\x1b')
                for s in serial_history[:5]
            ) if serial_history else 'None'
            stdscr.addstr(y, 0, f"Serial Buffer: {serial_display}", curses.color_pair(5))
            y += 1
            y += 1
            stdscr.move(y, 0)
            stdscr.clrtoeol()
            if playback_status == "Pausing":
                label = "Currently Pausing:"
            elif playback_status == "Restarting":
                label = "Currently Pending Restart:"
            else:
                label = "Currently Playing:"
            info_clean = ''.join(c for c in currently_playing if c in string.printable and c not in '\x1b')
            stdscr.addstr(y, 0, f"{label} {info_clean if info_clean else 'None'}", curses.color_pair(4))
            y += 1
            if currently_playing_info:
                if time.time() - currently_playing_info_timestamp < 5:
                    info2 = ''.join(c for c in currently_playing_info if c in string.printable and c not in '\x1b')
                    stdscr.addstr(y, 0, info2, curses.color_pair(4))
                else:
                    currently_playing_info = ""
                    currently_playing_info_timestamp = 0
            y += 1
            y += 1
            # COS and Remote Device Active indicators, side by side
            cos_state = is_cos_active()
            cos_color = curses.color_pair(2) if cos_state else curses.color_pair(5)
            remote_state = is_remote_device_active()  # you must define this function/variable in your backend
            remote_color = curses.color_pair(2) if remote_state else curses.color_pair(5)
            stdscr.addstr(y, 0, "COS Active: ", curses.color_pair(5))
            stdscr.addstr(f"{'YES' if cos_state else 'NO'}   ", cos_color | curses.A_BOLD)
            stdscr.addstr("Remote Device: ", curses.color_pair(5))
            stdscr.addstr(f"{'YES' if remote_state else 'NO'}", remote_color | curses.A_BOLD)
            y += 1
            y += 1
            stdscr.move(y, 0)
            stdscr.clrtoeol()
            max_y, _ = stdscr.getmaxyx()
            stdscr.move(max_y - 1, 0)
            stdscr.clrtoeol()
            stdscr.addstr(max_y - 1, 0, "Press q to quit", curses.color_pair(1))
            stdscr.refresh()
            try:
                if stdscr.getkey() == 'q':
                    break
            except curses.error:
                pass
            time.sleep(0.5)
        except Exception:
            log_exception("status_screen")

def bg_write_state_and_webcmd_loop():
    while True:
        maybe_run_webcmd()
        write_state()
        time.sleep(0.25)

def bg_cos_state_update_loop():
    global cos_active
    last_cos = None
    while True:
        try:
            cos_now = is_cos_active()
            if cos_now != last_cos:
                cos_active = cos_now
                last_cos = cos_now
        except Exception:
            pass
        time.sleep(0.05)

def fallback_command_prompt():
    print(f"{SCRIPT_NAME} v{VERSION} - Fallback Command Prompt")
    print("Enter DRX commands. Type 'exit' or 'quit' to exit.")
    while True:
        try:
            cmd = input("> ")
            if cmd.strip().lower() in ('exit', 'quit'):
                print("Exiting DRX.")
                sys.exit(0)
            process_command(cmd)
        except KeyboardInterrupt:
            print("\nExiting DRX by Ctrl+C.")
            sys.exit(0)
        except Exception as e:
            print(f"Error: {e}")

def get_drx_uptime():
    now = time.time()
    uptime_seconds = int(now - DRX_START_TIME)
    days, remainder = divmod(uptime_seconds, 86400)
    hours, remainder = divmod(remainder, 3600)
    minutes, seconds = divmod(remainder, 60)
    if days > 0:
        return f"{days}d {hours}h {minutes}m {seconds}s"
    elif hours > 0:
        return f"{hours}h {minutes}m {seconds}s"
    elif minutes > 0:
        return f"{minutes}m {seconds}s"
    else:
        return f"{seconds}s"

def launch_status_screen():
    import curses
    curses.wrapper(status_screen)

def main():
    try:
        threading.Thread(target=serial_read_loop, daemon=True).start()
        threading.Thread(target=process_serial_commands, daemon=True).start()
        threading.Thread(target=bg_write_state_and_webcmd_loop, daemon=True).start()
        threading.Thread(target=bg_cos_state_update_loop, daemon=True).start()
        try:
            curses.wrapper(status_screen)
        except Exception as e:
            print("Curses UI failed to start. Falling back to command prompt mode.")
            log_exception("main (curses fallback)")
            fallback_command_prompt()
            while True:
                time.sleep(1)
    except KeyboardInterrupt:
        pass
    except Exception:
        log_exception("main")
    finally:
        try:
            GPIO.cleanup()
        except Exception:
            log_exception("main (GPIO cleanup)")

if __name__ == "__main__":
    main()