import os
import json
import time
import configparser
import requests
import subprocess
import re
from flask import Flask, render_template_string, redirect, url_for, request, session, send_from_directory, jsonify, flash
from drx_main import VERSION

DRX_START_TIME = time.time()

# --- Load config for credentials and port ---
script_dir = os.path.dirname(os.path.realpath(__file__))
config_file_path = os.path.join(script_dir, 'config.ini')
config = configparser.ConfigParser()
config.read(config_file_path)

WEB_PORT = int(config.get("Web", "port", fallback="8080"))
WEB_USER = config.get("WebAuth", "username", fallback="admin")
WEB_PASS = config.get("WebAuth", "password", fallback="drxpass")
DTMF_LOG_FILE = os.path.join(script_dir, "logs", "dtmf.log")

STATE_FILE = os.path.join(script_dir, 'drx_state.json')  # NOTE: No longer used - kept for debug endpoint only
WEBCMD_FILE = '/tmp/drx_webcmd.json'
SOUND_DIRECTORY = config['Sound']['directory']
SOUND_FILE_EXTENSION = config['Sound']['extension']
LOG_FILE = '/home/drx/DRX/logs/drx.log'
CONFIG_TYPES = [
    ("Rotation", "Rotating"),
    ("Random", "Random"),
    ("SudoRandom", "SudoRandom"),
]
TOT_STATE = {
    'active': False,
    'start_time': None,
    'timeout_duration': 300  # 5 minutes in seconds
}


# --- State API Configuration ---
DRX_MAIN_API_URL = "http://127.0.0.1:5000/api/state"
HTTP_TIMEOUT = 2.0  # Timeout for HTTP requests to drx_main.py

app = Flask(__name__)
app.secret_key = "change_this_to_a_random_secret"

DASHBOARD_TEMPLATE = '''
<!doctype html>
<html>
<head>
<title>DRX Dashboard</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
<style>
/* Flashing COS LED for TOT */
@keyframes flash-red {
    0%, 50% { 
        background: #ff4343;
        border-color: #c40000;
        box-shadow: 0 0 6px 2px #ff4343cc, 0 2px 8px 0 rgba(30,30,70,0.13) inset;
    }
    51%, 100% { 
        background: #bbb;
        border-color: #888;
        box-shadow: none;
    }
}

.led-cos-flashing {
    animation: flash-red 1s infinite;
}
/* Play Local Modal */
#play-local-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    overflow: auto;
    background-color: rgba(0,0,0,0.4);
}

#play-local-modal .modal-content {
    background: #fefefe;
    margin: 10% auto;
    padding: 2em;
    border: 1px solid #888;
    width: 90%;
    max-width: 600px;
    border-radius: 14px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    text-align: center;
}

#play-local-modal h2 {
    color: var(--primary);
    margin-top: 0;
    margin-bottom: 1em;
}

#play-local-modal audio {
    width: 100%;
    max-width: 500px;
    margin: 1em 0;
}

#play-local-modal .close {
    color: var(--primary);
    float: right;
    font-size: 2em;
    font-weight: bold;
    cursor: pointer;
    margin-top: -10px;
}

#play-local-modal .close:hover {
    color: var(--danger);
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    #play-local-modal .modal-content {
        background: #272b38;
        color: #eee;
        border-color: #555;
    }
    
    /* Dark mode error styles - add these new styles */
    .base-error {
        border: 2px solid #ff7777 !important;
        background-color: rgba(255, 119, 119, 0.25) !important;
    }
    
    .validation-error {
        color: #ff7777;
        background-color: rgba(255, 119, 119, 0.15);
        border: 1px solid #ff7777;
    }
    
    #base-configurator-validation-summary {
        background-color: rgba(255, 119, 119, 0.15);
        border: 1px solid #ff7777;
        color: #ff7777;
    }
    
    /* Improve select element visibility */
    select {
        background-color: #2d333b; /* Dark background */
        color: #e6edf3; /* Light text */
        border: 1px solid #444c56;
    }
    
    /* Improve dropdown options visibility */
    select option {
        background-color: #2d333b; /* Dark background */
        color: #e6edf3; /* Light text */
    }
    
    /* Ensure the selected option is visible */
    select option:checked {
        background-color: #347d39; /* GitHub-style green */
        color: white;
    }
.status-last-played {
  font-size: .75em !important;
  /* Optional extras: */
  font-weight: bold;
  /* color: #1976d2 !important; /* optional blue color for visibility */ 
}
#playback-status {
  font-size: .75em !important;
  /* Optional extras: */
  font-weight: bold;
  /* color: #1976d2 !important; optional blue color for visibility */ */
}
/* Set the width of the GPIO Settings box */
.config-section.gpio-settings {
  width: 300px;          /* Change to your desired width, e.g., 500px or 60% */
  max-width: 100%;       /* Optional: prevents overflow on small screens */
  margin: 0 auto;        /* Optional: center the box horizontally */
}

/* Optional: Make sure the grid auto-rows are tall enough */
.config-sections {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 20px;
    margin-bottom: 20px;
    grid-auto-rows: minmax(150px, auto); /* adjust as needed */
}

/* Responsive: Stack full-width on small screens */
@media (max-width: 1100px) {
    .config-sections {
        grid-template-columns: repeat(2, 1fr);
    }
    .config-section.gpio-settings {
        grid-column: 1 / -1;
        grid-row: auto / span 2;
    }
}
@media (max-width: 700px) {
    .config-sections {
        grid-template-columns: 1fr;
    }
    .config-section.gpio-settings {
        grid-column: 1 / -1;
        grid-row: auto / span 2;
    }
}
.split-vertical {
  display: flex;
  flex-direction: column;
  height: 100%;
  gap: 8px;
}

.split-half {
  flex: 1 1 0;
  /* Optional: Add a border or divider for clarity */
  padding-bottom: 8px;
  border-bottom: 1px solid #ddd;
}

.split-half:last-child {
  border-bottom: none;
  padding-bottom: 0;
}
/* Condense Configuration Settings area */
.config-section {
    background: var(--primary-light);
    border-radius: 10px;
    padding: 9px 8px 8px 8px;
    margin-bottom: 7px;
    box-shadow: 0 2px 7px rgba(0,0,0,0.02);
}

.config-section h3 {
    color: var(--primary);
    margin-top: 0;
    margin-bottom: 7px;
    font-size: 1em;
    border-bottom: 1px solid rgba(0,0,0,0.07);
    padding-bottom: 3px;
}

.form-group {
    margin-bottom: 7px;
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 8px;
}

.form-group label {
    margin-bottom: 0;
    min-width: 90px;
    font-size: 0.93em;
    font-weight: 500;
}

.form-group input[type="text"], 
.form-group input[type="password"],
.form-group input[type="number"],
.form-group select {
    padding: 4px 6px;
    font-size: 0.97em;
    border-radius: 4px;
    border: 1px solid #bbb;
    width: 50px;
    min-width: 40px;
    max-width: 150px;
    box-sizing: border-box;
}
#sound_directory, #serial_port, #sound_device {
    width: 160px;
    max-width: 98%;
}
#cos_pin, #remote_busy_pin, #max_cos_interruptions {
    width: 50px;
}
#serial_timeout, #serial_line_timeout, #cos_debounce_time {
    width: 55px;
}
#web_username {
    width: 110px;
}

.form-group.checkbox {
    flex-direction: row;
    align-items: center;
    margin-bottom: 4px;
    gap: 6px;
}

.help-text {
    font-size: 0.78em;
    color: #666;
    margin-top: 0;
    margin-left: 4px;
    font-style: italic;
    max-width: 160px;
    line-height: 1.25;
}
#base-configurator-table input[type="text"] {
    box-sizing: border-box;
    padding: 4px 6px;
    font-size: 1em;
    border-radius: 4px;
    border: 1px solid #bbb;
    margin: 2px 0;
}
.dragging {
    opacity: 0.5;
}
.dragover {
    outline: 2px dashed #3949ab;
}
#base-configurator-table td {
    padding: 2px 5px;
    vertical-align: middle;
}
#base-configurator-table th {
    background: #e3e6f0;
}
#base-configurator-table input.base-no {
    width: 50px;
    box-sizing: border-box;
}
#base-configurator-table select.base-type {
    width: 100px;
    box-sizing: border-box;
}
#base-configurator-table textarea.base-desc,
#base-configurator-table input.base-desc {
    width: 100%;
    min-width: 100px;
    max-width: 100%;
    box-sizing: border-box;
}
#base-configurator-table td {
    padding: 2px 5px;
    vertical-align: middle;
}
#base-configurator-table select.base-type {
    width: 110px;
    padding: 3px 4px;
    font-size: 1em;
    border-radius: 4px;
    border: 1px solid #bbb;
}
#base-configurator-table {
    table-layout: fixed;
    width: 100%;
}
#base-configurator-table input.base-interval {
    width: 70px;
    min-width: 40px;
    max-width: 100px;
    box-sizing: border-box;
}
#base-configurator-table input.end-no {
    width: 60px;
    min-width: 40px;
    max-width: 90px;
    box-sizing: border-box;
}
</style>
<style>
:root {
  --primary: #3949ab;
  --primary-light: #e3e6f0;
  --accent: #1976d2;
  --success: #388e3c;
  --warning: #fbc02d;
  --danger: #d32f2f;
  --background: #f5f7fa;
  --card: #fff;
  --grey: #bdbdbd;
}
body {
  background: var(--background);
  font-family: 'Roboto', Arial, sans-serif;
  margin: 0;
  padding: 0;
}
#main-card {
  background: var(--card);
  max-width: 950px;
  margin: 40px auto;
  border-radius: 18px;
  box-shadow: 0 8px 32px 0 rgba(31,38,135,0.14);
  padding: 1em 3em;
  position: relative;
}
h1, h2 {
  color: var(--primary);
  font-weight: 700;
  letter-spacing: 1px;
}
h1 {
  margin-top: 0;
  font-size: 2.1em;
}
h2 {
  border-bottom: 1px solid var(--primary-light);
  padding-bottom: 0.3em;
  margin-top: 2em;
  margin-bottom: 0.8em;
  font-size: 1.3em;
}
.card-section {
  background: #fff;
  border: 1px solid #e2e2e2;
  border-radius: 12px;
  box-shadow: 0 2px 8px 0 rgba(31,38,135,0.09);
  margin: 24px auto;
  padding: 1.3em 1.6em;
  max-width: 950px;   /* Or whatever width you like */
  min-width: 280px;
  width: 100%;
  box-sizing: border-box;
}
form {
  margin-bottom: 1.3em;
}
input, select, textarea {
  font-size: 1.07em;
  border: 1.5px solid var(--grey);
  border-radius: 6px;
  padding: 0.45em;
  margin-right: 0.7em;
  background: #f9f9fc;
  color: #2d2d2d;
  transition: border 0.2s;
}
input:focus, select:focus, textarea:focus {
  outline: none;
  border-color: var(--primary);
}
button {
  font-size: 1.1em;
  border: none;
  border-radius: 6px;
  background: linear-gradient(90deg,var(--primary),var(--accent));
  color: #fff;
  padding: 0.53em 1.25em;
  cursor: pointer;
  transition: background 0.18s, box-shadow .18s;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  box-shadow: 0 1px 4px 0 rgba(31,38,135,0.07);
}
button:hover, button:focus {
  background: linear-gradient(90deg,var(--accent),var(--primary));
  box-shadow: 0 2px 8px 0 rgba(31,38,135,0.14);
}
#logout-btn { float: right; margin-top: 10px;}
.status-list li { font-size: 1.1em; margin-bottom: 0.7em;}
.status-good { color: var(--success); font-weight: bold; }
.status-warn { color: var(--warning); font-weight: bold; }
.status-bad { color: var(--danger); font-weight: bold; }
.logs, .serials {
  background: #212121; 
  color: #ececec; 
  font-family: 'Roboto Mono', monospace;
  font-size: 1em;
  padding: 1.1em; 
  border-radius: 9px; 
  margin-top: 0.7em; 
  margin-bottom: 1.2em; 
  overflow-x: auto; 
  max-height: 220px;
}
pre.stateblock {
  background: var(--primary-light);
  color: #222;
  padding: 1.1em;
  border-radius: 9px;
  font-family: 'Roboto Mono', monospace;
  font-size: 1em;
  margin: 0 0 1em 0;
  white-space: pre-line;
}
.label {
  background: var(--primary);
  color: #fff;
  border-radius: 4px;
  padding: 0.13em 0.56em;
  font-size: 1em;
  margin-right: 0.44em;
}
#message-timer {
  display: inline-block;
  font-size: 1.25em;
  font-weight: 700;
  background: #fff;
  border: 2px solid var(--primary);
  color: var(--primary);
  border-radius: 7px;
  padding: 0.1em 0.6em;
  min-width: 64px;
  text-align: center;
  margin-left: 0.6em;
  transition: color 0.2s, border 0.2s, background 0.2s;
}
#message-timer.ready {
  color: var(--success);
  border-color: var(--success);
  background: #e4fbe7;
}
#message-timer.running {
  color: var(--danger);
  border-color: var(--danger);
  background: #ffeaea;
}
/* Modal styling */
.modal {
  display: none; position: fixed; z-index: 999; left: 0; top: 0; width: 100vw; height: 100vh;
  overflow: auto; background-color: rgba(0,0,0,0.33);
}
.modal-content {
  background: #fefefe; margin: 7% auto; padding: 2em; border: 1px solid #888; width: 96%; max-width: 540px; border-radius: 14px; box-shadow: 0 4px 20px #3333;
  animation: popupIn 0.33s;
}
@keyframes popupIn {
  from { transform: scale(0.95); opacity: 0;}
  to   { transform: scale(1); opacity: 1;}
}
.close {
  color: var(--primary); float: right; font-size: 2em; font-weight: bold; cursor: pointer;
}
.close:hover { color: var(--danger); }
@media (max-width: 700px) {
  #main-card { padding: 1.1em 0.5em;}
  h1 { font-size: 1.4em;}
  h2 { font-size: 1.09em;}
  .card-section { padding: 0.7em 0.5em;}
  button { width: 100%; }
  #logout-btn { float: none; margin-top: 8px; }
  .modal-content { width: 99vw; padding: 1.2em; }
}
.bases-block {
  background: #e3e6f0;
}
.stateblock-1 { background: #cdd5df !important; }
.stateblock-2 { background: #cdd5df !important; }
.stateblock-3 { background: #cdd5df !important; }
.stateblock-4 { background: #cdd5df !important; }
.stateblock {
  color: #222;
  padding: 1em;
  border-radius: 8px;
  font-family: 'Roboto Mono', monospace;
  font-size: 1em;
  margin: 0 0 1em 0;
  white-space: pre-line;
  box-shadow: 0 1px 4px 0 rgba(31,38,135,0.03);
}
.modal {
  display: none; position: fixed; z-index: 999; left: 0; top: 0; width: 100vw; height: 100vh;
  overflow: auto; background-color: rgba(0,0,0,0.33);
}
.modal-content {
  background: #fefefe; margin: 7% auto; padding: 2em; border: 1px solid #888; width: 96%; max-width: 1000px; border-radius: 14px; box-shadow: 0 4px 20px #3333;
  animation: popupIn 0.33s;
}
@keyframes popupIn {
  from { transform: scale(0.95); opacity: 0;}
  to   { transform: scale(1); opacity: 1;}
}
.close {
  color: #3949ab; float: right; font-size: 2em; font-weight: bold; cursor: pointer;
}
.close:hover { color: #d32f2f; }
.config-section {
    background: var(--primary-light);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
.config-section h3 {
    color: var(--primary);
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.1em;
    border-bottom: 1px solid rgba(0,0,0,0.1);
    padding-bottom: 8px;
}
.form-group {
    margin-bottom: 12px;
    display: flex;
    flex-direction: column;
}
.form-group label {
    margin-bottom: 5px;
    font-weight: 500;
    font-size: 0.95em;
}
.form-group input[type="text"], 
.form-group input[type="password"],
.form-group input[type="number"],
.form-group select {
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: 100%;
    box-sizing: border-box;
}
.form-group.checkbox {
    flex-direction: row;
    align-items: center;
}
.form-group.checkbox input[type="checkbox"] {
    margin-right: 8px;
}
.form-group.checkbox label {
    margin-bottom: 0;
}
@media (max-width: 700px) {
    .config-sections {
        grid-template-columns: 1fr;
    }
}
/* Config form styling */
.config-sections {
  display: flex;
  flex-wrap: wrap;
  gap: 18px;
}
.help-text {
    font-size: 0.85em;
    color: #666;
    margin-top: 3px;
    font-style: italic;
}
.button-row {
    display: flex;
    flex-direction: row;
    gap: 10px;
    justify-content: flex-start;
    align-items: center;
}
.button-row form {
    margin: 0;
}
@media (max-width: 700px) {
    .button-row {
        flex-direction: column;
        align-items: stretch;
    }
    .button-row form {
        width: 100%;
    }
}
.logs {
  overflow-y: auto;
  max-height: 220px;
}
@media (prefers-color-scheme: dark) {
  :root {
    --primary: #90a4ff;
    --primary-light: #22263a;
    --accent: #5c6bc0;
    --success: #6fd36f;
    --warning: #ffe082;
    --danger: #ff867f;
    --background: #181c26;
    --card: #23272b;
    --grey: #888;
  }
  body {
    background: var(--background);
    color: #f0f0f0;
  }
  .card-section, .config-section {
    background: #494a49;
    color: #f0f0f0;
    box-shadow: 0 2px 8px 0 rgba(31,38,135,0.19);
  }
  #main-card {
    background: var(--card);
    color: #f0f0f0;
  }
  .logs, .serials {
    background: #000000;
    color: #eee;
  }
  .stateblock {
    background: #939393 !important; /* Change this to your preferred dark background color */
    color: #000000 !important;      /* Optional: ensures text is readable in dark mode */
  }
  input, select, textarea {
    background: #23272b;
    color: #eee;
    border-color: #555;
  }
  .modal-content {
    background: #272b38;
    color: #eee;
  }
  #message-timer {
    background: #23272b;         /* or var(--card) or a dark color */
    color: var(--primary);       /* or #90a4ff for blue accent */
    border: 2px solid var(--primary);
  }
  #message-timer.ready {
    color: var(--success);       /* you can keep this or lighten it */
    border-color: var(--success);
    background: #163021;         /* a dark green shade, or use var(--card) */
  }
  #message-timer.running {
    color: var(--danger);
    border-color: var(--danger);
    background: #3a2121;         /* a dark red shade, or var(--card) */
  }  
  #base-configurator-table th {
    background: #2a2e3a !important;   /* A dark blue/gray */
    color: #fff;           /* White text */  
  }
  .config-sections .config-section {
    background: #011f4b; /* Warm dark brown/orange for dark mode, adjust as desired */
  }
  #base-configurator-validation-summary {
    background-color: #3a2121;
    border: 1px solid #ff867f;
    color: #ff867f;
  } 
}
.your-card { margin-bottom: 0.8em; }
.card-section.center-buttons {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0.5em 0;    /* ensures enough space for vertical centering */
  /* or use height: 100px; if you want a fixed height */
  /* or use padding for flexible height */
}
select[name="track_dropdown"] {
    min-width: 100px;
    max-width: 100%;
}
</style>
<script>
let updateStatus;
document.addEventListener("DOMContentLoaded", function() {
    // Play Local Modal elements
    const playLocalModal = document.getElementById('play-local-modal');
    const playLocalTitle = document.getElementById('play-local-title');
    const playLocalAudio = document.getElementById('play-local-audio');
    const playLocalSource = document.getElementById('play-local-source');
    const closePlayLocal = document.getElementById('close-play-local');
    const playLocalCloseBtn = document.getElementById('play-local-close-btn');

    // Play Local Modal functions
    function openPlayLocalModal(filename) {
        playLocalTitle.textContent = `Playing: ${filename}`;
        playLocalSource.src = `/audio/${filename}`;
        playLocalAudio.load(); // Reload the audio element
        playLocalModal.style.display = 'block';
    }

    function closePlayLocalModal() {
        playLocalModal.style.display = 'none';
        playLocalAudio.pause();
        playLocalAudio.currentTime = 0;
        playLocalSource.src = '';
    }

    // Modal close events
    if (closePlayLocal) {
        closePlayLocal.onclick = closePlayLocalModal;
    }
    if (playLocalCloseBtn) {
        playLocalCloseBtn.onclick = closePlayLocalModal;
    }
    
    // Close modal when clicking outside
    window.onclick = function(event) {
        if (event.target == playLocalModal) {
            closePlayLocalModal();
        }
    };

    // Close modal with Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape' && playLocalModal.style.display === 'block') {
            closePlayLocalModal();
        }
    });

// Play Selected (dropdown) form
const dropdownForm = document.getElementById('play-dropdown-form');
if (dropdownForm) {
    dropdownForm.addEventListener('submit', function(event) {
        event.preventDefault();
        const formData = new FormData(dropdownForm);
        fetch(dropdownForm.action, {
            method: 'POST',
            body: formData,
            credentials: 'same-origin',
            headers: {'X-Requested-With': 'XMLHttpRequest'}
        })
        .then(response => response.json())
        .then(data => {
            if (data.local_play && data.filename) {
                // Open modal with the filename
                openPlayLocalModal(data.filename);
            } else {
                // Normal DRX play - update status
                updateStatus();
                updateSerialSection();
                updateLogsSection();
                updateStateSection();
            }
        });
    });
}
// Play Input form
const inputForm = document.getElementById('play-input-form');
if (inputForm) {
    inputForm.addEventListener('submit', function(event) {
        event.preventDefault();
        const formData = new FormData(inputForm);
        fetch(inputForm.action, {
            method: 'POST',
            body: formData,
            credentials: 'same-origin',
            headers: {'X-Requested-With': 'XMLHttpRequest'}
        })
        .then(response => response.json())
        .then(data => {
            if (data.local_play && data.filename) {
                // Open modal with the filename
                openPlayLocalModal(data.filename);
            } else {
                // Normal DRX play - update status
                updateStatus();
                updateSerialSection();
                updateLogsSection();
                updateStateSection();
            }
        });
    });
}

    function updateMessageTimer() {
        fetch("/api/message_timer", {credentials: 'same-origin'})
        .then(response => response.json())
        .then(data => {
            const el = document.getElementById('message-timer');
            if (!el) return;
            if (data.seconds_left > 0) {
                const mins = Math.floor(data.seconds_left / 60);
                const secs = data.seconds_left % 60;
                if (mins > 0) {
                    el.textContent = `${mins}m ${secs.toString().padStart(2, '0')}s`;
                } else {
                    el.textContent = `${secs}s`;
                }
                el.classList.add("running");
                el.classList.remove("ready");
            } else {
                el.textContent = "Ready";
                el.classList.add("ready");
                el.classList.remove("running");
            }
        });
    }
    setInterval(updateMessageTimer, 1000);
    updateMessageTimer();

    // Poll status every second
updateStatus = function() {
    fetch("{{ url_for('status_api') }}", {credentials: 'same-origin'})
    .then(response => response.json())
    .then(data => {
        document.querySelectorAll('.status-currently-playing').forEach(function(el) {
            el.textContent = data.currently_playing || "None";
        });
        document.querySelectorAll('.status-last-played').forEach(function(el) {
            el.textContent = data.last_played || "None";
        });
        if (document.getElementById('playback-status')) {
            let statusLabel = data.playback_status || "Idle";
            if (statusLabel === "Restarting") {
                statusLabel = "Pending Restart";
            }
            document.getElementById('playback-status').textContent = statusLabel;
        }
        
        // COS LED with TOT flashing support
        const cosLed = document.getElementById('cos-led');
        if (cosLed) {
            // Remove all previous classes
            cosLed.className = 'led-indicator';
            
            if (data.tot_active) {
                // TOT is active - flash red regardless of COS state
                cosLed.classList.add('led-cos-flashing');
                cosLed.title = 'TOT Active - Time Out Timer Running';
            } else if (data.cos_state) {
                // Normal COS active
                cosLed.classList.add('led-cos-active');
                cosLed.title = 'COS Active';
            } else {
                // COS inactive
                cosLed.classList.add('led-inactive');
                cosLed.title = 'COS Inactive';
            }
        }
        
        // Remote Device LED (unchanged)
        const rdbLed = document.getElementById('remote-device-led');
        if (rdbLed) {
            if (data.remote_device_active) {
                rdbLed.className = 'led-indicator led-remote-active';
                rdbLed.title = 'Remote Device Active';
            } else {
                rdbLed.className = 'led-indicator led-inactive';
                rdbLed.title = 'Remote Device Inactive';
            }
        }
    });
};

    function updateSerialSection() {
        fetch("{{ url_for('api_serial_commands') }}", {credentials: 'same-origin'})
        .then(response => response.text())
        .then(html => {
            document.getElementById('serial-section').innerHTML = html;
        });
    }

    function updateLogsSection() {
        fetch("{{ url_for('api_log_entries') }}", {credentials: 'same-origin'})
        .then(response => response.text())
        .then(html => {
            document.getElementById('logs-section').innerHTML = html;
        });
    }

    function updateStateSection() {
        fetch("{{ url_for('api_state_blocks') }}", {credentials: 'same-origin'})
        .then(response => response.text())
        .then(html => {
            document.getElementById('state-section').innerHTML = html;
        });
    }

function updateCosMinutes() {
    fetch("/api/cos_minutes", {credentials: 'same-origin'})
    .then(response => response.json())
    .then(data => {
        const el = document.getElementById('cos-today-minutes');
        if (el) el.textContent = data.cos_today_minutes;
    });
}

    setInterval(updateCosMinutes, 1000);
    updateCosMinutes();
    setInterval(updateStatus, 100);
    setInterval(updateSerialSection, 1000);
    setInterval(updateLogsSection, 1000);
    setInterval(updateStateSection, 1000);

    updateStatus();
    updateSerialSection();
    updateLogsSection();
    updateStateSection();

    // Help Modal
    var helpBtn = document.getElementById('help-btn');
    var helpModal = document.getElementById('help-modal');
    var closeBtn = document.getElementById('close-help');
    if (helpBtn && helpModal && closeBtn) {
        helpBtn.onclick = function() { helpModal.style.display = "block"; };
        closeBtn.onclick = function() { helpModal.style.display = "none"; };
        window.onclick = function(event) {
            if (event.target == helpModal) { helpModal.style.display = "none"; }
        };
    }
});
function updateUptime() {
    fetch("{{ url_for('api_drx_uptime') }}", {credentials: 'same-origin'})
    .then(response => response.json())
    .then(data => {
        var up = document.getElementById('drx-uptime');
        if(up) {
            up.textContent = data.drx_uptime;
            if(data.not_running) {
                up.classList.add('flash-red');
            } else {
                up.classList.remove('flash-red');
            }
        }
    });
}
setInterval(updateUptime, 1000);
window.addEventListener('DOMContentLoaded', updateUptime);
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Convert Python boolean strings to proper checkbox state
    const checkboxes = document.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(function(checkbox) {
        if (checkbox.getAttribute('data-value') === 'True') {
            checkbox.checked = true;
        }
    });
});
</script>
</head>
<body>
<div id="main-card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h1 style="margin: 0; font-size: 2.1em;">DRX Status Dashboard</h1>
        <div style="display: flex; gap: 10px; align-items: center;">
            <button id="help-btn" type="button">Help</button>
            <form method="POST" action="{{ url_for('logout') }}" id="logout-btn" style="margin: 0;">
                <button type="submit">Logout</button>
            </form>
        </div>
    </div>
    
    <!-- Create a flex container to align version info with uptime info -->
    <div style="display: flex; justify-content: space-between; margin-top: 5px;">
        <!-- Left side: Uptime and Activity -->
        <div>
            <div><b>DRX Uptime:</b> <span id="drx-uptime">{{ drx_uptime }}</span></div>
            <div class="your-card">
                <b>Minutes of Activity:</b> <span id="cos-today-minutes" class="status-good" style="font-size:1.15em;">
                    {{ state.get('cos_today_minutes', 0) }}
                </span>
            </div>
        </div>
        
        <!-- Right side: Version info -->
        <div class="version-info" style="text-align: right; font-size: 0.8em; color: #777;">
            <div>Main Ver: {{ version }}</div>
            <div>Web Ver: {{ web_version }}</div>
        </div>
    </div>
</div>
<div class="card-section play-track-flex">
    <div class="play-track-main">
        <h2>Play Specific Track</h2>
        <!-- Single Play Method selector for both forms -->
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 18px;">
            <label style="white-space: nowrap;">Play Method:</label>
            <select id="play_method_selector" name="play_method" style="width: 150px; min-width: 80px;">
                <option value="normal" selected>Normal (DRX)</option>
                <option value="local">Local (Web Page)</option>
            </select>
        </div>
        <form method="POST" action="{{ url_for('play_track') }}" id="play-dropdown-form">
            <input type="hidden" name="play_method" id="play_method_dropdown">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 18px;">
                <label for="track_dropdown" style="white-space: nowrap;">Track:</label>
                <select name="track_dropdown" id="track_dropdown">
                    <option value="">--Select--</option>
                    {% for file in all_files %}
                        <option value="{{ file }}">{{ file }}</option>
                    {% endfor %}
                </select>
                <button type="submit" style="margin: 0;">&#9654;</button>
            </div>
        </form>
        <form method="POST" action="{{ url_for('play_track') }}" id="play-input-form" style="margin-top: 28px;">
            <input type="hidden" name="play_method" id="play_method_input">
            <div style="display: flex; flex-direction: column; gap: 0;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="track_input" style="white-space: nowrap;">Track:</label>
                    <input name="track_input" id="track_input" type="text" placeholder="Input Serial Data if DRX" size="20">
                    <button type="submit" style="margin: 0;">&#9654;</button>
                    <small class="help-text">For Normal (DRX) Play, enter serial data to test (e.g., P5308i6000).  For Local (Web Page) play, enter EXACT full wav file name (e.g., 5308-test.wav, 2021.WAV, 3022.wav</small>
                </div>
            </div>
        </form>
        <br>
        <b>Currently Playing:</b>
        <span class="status-good status-currently-playing">{{ currently_playing or "None" }}</span>
        <form method="POST" action="{{ url_for('stop_playback') }}" style="display:inline; margin-left:1em;">
            <button type="submit" style="margin: 0;">&#9632;</button>
        </form>
    </div>
    <div class="play-track-subcard">
        <div class="subcard-title">Message Timer</div>
        <div class="subcard-timer">
            <span id="message-timer" class="ready">Ready</span>
        </div>
        <div class="subcard-row">
            <div class="subcard-label">Last Played:</div>
            <div class="subcard-value status-good status-last-played">{{ last_played or "None" }}</div>
        </div>
        <div class="subcard-row">
            <div class="subcard-label">Status:</div>
            <div class="subcard-value" id="playback-status">{{ playback_status or "Idle" }}</div>
        </div>
        <div class="subcard-row">
            <div class="subcard-label">COS Active:</div>
            <div class="subcard-value">
                <span id="cos-led" class="led-indicator led-inactive"></span>
            </div>
        </div>
        <div class="subcard-row">
            <div class="subcard-label">Remote Device Active:</div>
            <div class="subcard-value">
                <span id="remote-device-led" class="led-indicator led-inactive"></span>
            </div>
        </div>
        <div class="subcard-row">
            <div class="subcard-label">Serial Port:</div>
            <div class="subcard-value">
            {% if not serial_port_missing %}
                <span class="status-good">OK</span>
            {% else %}
                <span class="status-bad">Missing</span>
            {% endif %}
            </div>
        </div>
        <div class="subcard-row">
            <div class="subcard-label">Sound Card:</div>
            <div class="subcard-value">
            {% if not sound_card_missing %}
                <span class="status-good">OK</span>
            {% else %}
                <span class="status-bad">Missing</span>
            {% endif %}
            </div>
        </div>
        <div class="subcard-row">
            <div class="subcard-label">Weather System:</div>
            <div class="subcard-value">
                <span class="{{ weather_class }}" style="color: {{ weather_color }};">{{ weather_status }}</span>
            </div>
        </div>
    </div>
</div>
<style>
.play-track-flex {
  display: flex;
  flex-direction: row;
  gap: 24px;
}
.play-track-main {
  flex: 1 1 0;
  min-width: 0;
}
.play-track-subcard {
  flex: 0 0 220px;
  width: 220px;
  min-width: 220px;
  max-width: 220px;
  background: var(--primary-light);
  border-radius: 12px;
  box-shadow: 0 2px 8px 0 rgba(31,38,135,0.09);
  padding: 1em 1.4em;
  margin-top: 22px;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.subcard-title {
  font-size: 1.13em;
  font-weight: 700;
  color: var(--primary);
  margin-bottom: 0.7em;
  letter-spacing: 1px;
}
.subcard-timer {
  font-size: 1.6em;
  font-weight: 700;
  margin-bottom: 0.8em;
  width: 100%;
  display: flex;
  justify-content: center;
}
#message-timer {
  display: inline-block;
  min-width: 80px;
  width: 80px;
  text-align: center;
  font-size: 0.75em;
  font-weight: 500;
  background: #fff;
  border: 2px solid var(--primary);
  color: var(--primary);
  border-radius: 7px;
  padding: 0.1em 0.6em;
  transition: color 0.2s, border 0.2s, background 0.2s;
}
.subcard-row {
  display: flex;
  width: 100%;
  justify-content: space-between;
  align-items: center;
  margin-top: 0.9em;
  flex-wrap: nowrap;
}
.subcard-label, .subcard-value {
  display: flex;
  align-items: center;
  margin: 0;
  padding: 0;
}
.subcard-label {
  font-size: 1em;
  color: var(--primary);
  font-weight: 500;
  min-width: 110px;
  max-width: 110px;
}
.subcard-value {
  font-size: 1.1em;
}
@media (max-width: 900px) {
  .play-track-flex {
    flex-direction: column;
    align-items: center;
  }
  .play-track-subcard {
    margin-top: 22px;
    margin-left: auto;
    margin-right: auto;
    width: 220px;
    min-width: 220px;
    max-width: 220px;
    align-self: center;
  }
}
.led-indicator {
  display: inline-block;
  width: 19px;
  height: 19px;
  border-radius: 6px;
  margin-right: 6px;
  background: #bbb;
  border: 2.5px solid #666;
  box-shadow: 0 2px 8px 0 rgba(30,30,70,0.13) inset;
  vertical-align: middle;
  transition: background 0.2s, box-shadow 0.2s, border 0.2s;
}
.led-cos-active {
  background: #29aaff;
  border-color: #2266ff;
  box-shadow: 0 0 6px 2px #29aaffcc, 0 2px 8px 0 rgba(30,30,70,0.13) inset;
}
.led-remote-active {
  background: #ff4343;
  border-color: #c40000;
  box-shadow: 0 0 6px 2px #ff4343cc, 0 2px 8px 0 rgba(30,30,70,0.13) inset;
}
.led-inactive {
  background: #bbb;
  border-color: #888;
  box-shadow: none;
}

</style>
<script>
document.addEventListener("DOMContentLoaded", function() {
    // 1. Initialize hidden fields to match selector on page load
    var method = document.getElementById('play_method_selector').value;
    document.getElementById('play_method_dropdown').value = method;
    document.getElementById('play_method_input').value = method;

    // 2. Update hidden fields whenever selector changes
    document.getElementById('play_method_selector').addEventListener('change', function() {
        var method = this.value;
        document.getElementById('play_method_dropdown').value = method;
        document.getElementById('play_method_input').value = method;
    });

    // 3. Always sync hidden field before AJAX submit
    function syncPlayMethodHidden(hiddenId) {
        var method = document.getElementById('play_method_selector').value;
        document.getElementById(hiddenId).value = method;
    }

    const dropdownForm = document.getElementById('play-dropdown-form');
    if (dropdownForm) {
        dropdownForm.addEventListener('submit', function(event) {
            syncPlayMethodHidden('play_method_dropdown');
            event.preventDefault();
            const formData = new FormData(dropdownForm);
            fetch(dropdownForm.action, {
                method: 'POST',
                body: formData,
                credentials: 'same-origin',
                headers: {'X-Requested-With': 'XMLHttpRequest'}
            })
            .then(response => response.json())
            .then(data => {
                if (data.local_url) {
                    window.location = data.local_url;
                }
                if (typeof updateStatus === "function") updateStatus();
                if (typeof updateSerialSection === "function") updateSerialSection();
                if (typeof updateLogsSection === "function") updateLogsSection();
                if (typeof updateStateSection === "function") updateStateSection();
            });
        });
    }

    const inputForm = document.getElementById('play-input-form');
    if (inputForm) {
        inputForm.addEventListener('submit', function(event) {
            syncPlayMethodHidden('play_method_input');
            event.preventDefault();
            const formData = new FormData(inputForm);
            fetch(inputForm.action, {
                method: 'POST',
                body: formData,
                credentials: 'same-origin',
                headers: {'X-Requested-With': 'XMLHttpRequest'}
            })
            .then(response => response.json())
            .then(data => {
                if (data.local_url) {
                    window.location = data.local_url;
                }
                if (typeof updateStatus === "function") updateStatus();
                if (typeof updateSerialSection === "function") updateSerialSection();
                if (typeof updateLogsSection === "function") updateLogsSection();
                if (typeof updateStateSection === "function") updateStateSection();
            });
        });
    }
});
</script>
        <!-- Help Modal HTML -->
        <div id="help-modal" class="modal">
          <div class="modal-content">
            <span class="close" id="close-help">&times;</span>
            <h2>Help: DRX (Digital Repeater Xpander)</h2>
            <ul>
              <li><b>Play Specific Track:</b> Use the dropdown to select a track or use the input to specify one directly.</li>
              <li><b>Play Method:</b> 
                <ul>
                  <li><b>Normal (DRX):</b> Sends the play command to the DRX backend, which plays it on the repeater.</li>
                  <li><b>Local (Web Page):</b> Plays the audio in your web browser only (does not transmit on repeater). You must enter the full file name in input box (1001.wav).</li>
                </ul>
              </li>
              <li>If you input serial data, use the correct format as expected by your DRX system.  Web commands do not need the &#92;n as shown below.</li>
              <li>You can use either method to play tracks, but only one at a time.</li>
                <ul>
              <h3>Play Functions </h3>
              All tracks must start with a P and end with &#92;n or in decimal 010.  Do not confuse this with a slash and the letter n. &#92;n means newline.
              <br>
              <br>
                  <li><b>I:</b> Interrupts the wav - P1001I.</li>
                  <li><b>R:</b> Repeats the wav - P1001R.  Repeats x number of times until plays through. *</li>
                  <li><b>P:</b> Pauses the wav - P1001P.  Pauses x number of times before giving up. *</li>
                  <li><b>W:</b> Waits for COS (including debounce) to go inactive before playing the wav - P1001W. *</li>
                  <li><b>M:</b> Message that plays when timer expires P1001M, P1001RM, P2000A5000M (means 2000 will always play, 5000 will only play when timer expired.  For example, a tail message that won't play more than x minutes. *</li>
                  <li><b>A:</b> Alternates between Bases and/or Single Tracks.  P4000A5000A6000I (example with Repeat suffix).  This can cross base types. </li>
                  <li><b>J:</b> Joins Bases and/or Single Tracks.  P5189RJ5300I (example with Repeat and Interrupt suffixes).  This can cross base types. </li>
                  <li><b>J/A:</b> You can combine J and A with suffixes into one command such as: P5600WJ5050PA5600i6000 </li>
                  <li><b>i:</b> Interrupts primary wav and immediately plays secondary even if COS active - P3050i3000, P5600i6000A5050i6000A5600i6000.  The i command is not supported with the J suffix.</li>
              <h3>Record Functions</h3>
              All tracks must start with an R and end with &#92;n).
              <br>
              <br>
                  <li><b>Re</b> Brings up an "Echo Test" to record and playback user - Re9999 (where 9999 is the track to record).  The recorded track does not get overwritten until called again, so you can have multiple commands to store different tracks.  Track recording stops automatically after 1 minute if COS doesn't become inactive prior.  If recording doesn't start within 5 seconds, Echo Test aborts (echo-to.wav). Required files are "echo-start.wav", "echo-to.wav", and optional "echo-end.wav".  Place them in the "sounds" directory.  Set COS debounce time in config for fluttering signals. *</li>
              <h3>Special Functions:</h3>
                  <li><b>S:</b> Scripts - Can call a 4 digit script number in the DRX/scripts folder -> S1001 &#92;n.</li>
                  <li><b>W1:</b> Weather Conditions, if cos was active in the last 10 seconds, jumps to W2 -> W1 &#92;n. **</li>
                  <li><b>W1F:</b> Weather Conditions Forced, same as W1 but doesn't have the cos rule -> W1F &#92;n. **</li>
                  <li><b>W2:</b> Temperature -> W2 &#92;n. **</li>
                  <li><b>A1:</b> Activity Announcement "A1 &#92;n" - When called, announces the repeater activity for yesterday.  Need announce.wav, minute.wav, minutes.wav, and number files (1.wav,100.wav, etc. **)
                  <li><b>TOT:</b> Time Out Timer - Command starts recording seconds in RAM for playback. </li>
                  <li><b>TOP:</b> Time Out Play - Plays to1.wav -number of seconds- seconds.wav to2.wav. </li>
                  <li><b>xDy:</b> DTMF logging - Sent from controller DTMF detected macro.  x is the port number (1,2,3) D is the DRX command and y is the serial variable from the controller that gives the DTMF entered value - 1D4 would show as Port 1 DTMF digit 4. </li>
              <h3>Bases:</h3> 
                  A base type is called by sending P&lt;base #&gt;.  <br>Example: config.ini defines rotating base as base=4200,end=4210,interval=5, P4200, will play 4201.wav and cycle to 4202.wav after 5 minutes.  This will continue and loop back to 4201.
                  <br>
                  Enter in controller as P<base> &#92;n - P5300&#92;n
                  <br>
                  <li><b>Rotation</b> Rotations through the tracks in the base +1 to end tracks. Changes to next track at interval expiration. *</li>
                  <li><b>Random</b> Randomly plays the tracks in the base +1 to end tracks. Changes to next track at interval expiration. *</li>
                  <li><b>SudoRandom</b> Pseudo random - same as random except plays all tracks in a base group before playing again.  Won't play same track in 2 cycles. *</li>
                  <br>
                  * Defined in Configuration Settings.
                  <br>
                  ** Waits for cos inactive with debounce.</li>
                  <br>
                </ul>
              </li>
          </div>
        </div>
    </div>
    <div class="card-section">
    <h2>Recent Log Entries</h2>
    <div class="logs" id="logs-section">
    {% for entry in web_log %}
        <div>{{ entry }}</div>
    {% endfor %}
    </div>
    <a href="{{ url_for('download_drx_log') }}">Download Full DRX Log</a>
    </div>
    <div class="card-section">
        <h2>Recent Serial Commands</h2>
        <div class="serials" id="serial-section">
        {% for cmd in serial_history[:5] %}
            <div>{{ cmd }}</div>
        {% endfor %}
        </div>
    </div>
    <div class="card-section">
    <h2>Recent DTMF Entries</h2>
    <div class="logs" id="dtmf-log-section">
        Loading...
    </div>
    <a href="{{ url_for('download_dtmf_log') }}">Download Full DTMF Log</a>
    </div>
    <!-- === State section now comes after log section === -->
    <div class="card-section" id="state-section">
        {{ state_blocks_html|safe }}
    </div>
    <div class="card-section center-buttons">
        <div class="button-row">
            <form method="POST" action="{{ url_for('restart_script_web') }}">
                <button type="submit" onclick="return confirm('Restart the DRX?')">Restart DRX</button>
            </form>
            <form method="POST" action="{{ url_for('reboot_system_web') }}">
                <button type="submit" onclick="return confirm('Reboot the system?')">Reboot System</button>
            </form>
            <form method="POST" action="{{ url_for('reload_config_web') }}">
                <button type="submit">Reload Configuration File</button>
            </form>
        </div>
    </div>
<script>
function updateDtmfLog() {
    fetch("{{ url_for('api_dtmf_log') }}")
    .then(response => response.text())
    .then(html => {
        document.getElementById('dtmf-log-section').innerHTML = html;
    });
}
setInterval(updateDtmfLog, 2000);
window.addEventListener('DOMContentLoaded', updateDtmfLog);
document.addEventListener("DOMContentLoaded", function() {
    function syncPlayMethod(event) {
        var method = document.getElementById('play_method_selector').value;
        document.getElementById('play_method_dropdown').value = method;
        document.getElementById('play_method_input').value = method;
    }
    document.getElementById('play-dropdown-form').addEventListener('submit', syncPlayMethod);
    document.getElementById('play-input-form').addEventListener('submit', syncPlayMethod);
});
</script>
<div class="card-section">
    <h2>Configuration Settings</h2>
    <div style="margin-top: 12px; display: flex; justify-content: center;">
        <button type="button" id="base-configurator-btn">Base Configurator</button>
    </div>
    <br>
    <form method="POST" action="{{ url_for('edit_config_structured') }}" id="config-form">
        <div class="config-sections">
            <!-- General Settings + Debug Options (stacked in one card) -->
            <div class="config-section">
                <div class="split-vertical">
                    <div class="split-half">
                        <h3>General Settings</h3>
                        <div class="form-group">
                            <label for="message_timer">Message Timer (minutes):</label>
                            <input type="number" id="message_timer" name="message_timer" min="0" max="120" value="{{ config.get('General', 'Message Timer', fallback='10') }}">
                            <small class="help-text">Time before message (P1234M) plays again. Could be used so a tail message doesn't play every tail drop.</small>
                        </div>
                    </div>
                    <div class="split-half">
                        <h3>Debug Options</h3>
                        <div class="form-group checkbox">
                            <input type="checkbox" id="enable_cos_override" name="enable_cos_override" {% if config.get('Debug', 'enable_cos_override', fallback='false').lower() == 'true' %}checked{% endif %}>
                            <label for="enable_cos_override">Enable COS Override</label>
                        </div>
                        <div class="form-group checkbox">
                            <input type="checkbox" id="enable_debug_logging" name="enable_debug_logging" {% if config.get('Debug', 'enable_debug_logging', fallback='false').lower() == 'true' %}checked{% endif %}>
                            <label for="enable_debug_logging">Enable Debug Logging</label>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Serial Settings -->
            <div class="config-section">
                <h3>Serial Settings</h3>
                <div class="form-group">
                    <label for="serial_port">Serial Port:</label>
                    <input type="text" id="serial_port" name="serial_port" value="{{ config.get('Serial', 'port', fallback='/dev/ttyUSB0') }}">
                </div>
                <div class="form-group">
                    <label for="serial_baudrate">Baud Rate:</label>
                    <select id="serial_baudrate" name="serial_baudrate">
                        {% for rate in [1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200] %}
                            <option value="{{ rate }}" {% if config.get('Serial', 'baudrate', fallback='57600')|int == rate %}selected{% endif %}>{{ rate }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="form-group">
                    <label for="serial_timeout">Timeout (seconds):</label>
                    <input type="number" id="serial_timeout" name="serial_timeout" min="0.1" max="10" step="0.1" value="{{ config.get('Serial', 'timeout', fallback='0.5') }}">
                    <small class="help-text">Time DRX waits for controller to send serial data.</small>
                </div>
                <div class="form-group">
                    <label for="serial_line_timeout">Line Timeout (seconds):</label>
                    <input type="number" id="serial_line_timeout" name="serial_line_timeout" min="0.1" max="10" step="0.1" value="{{ config.get('Serial', 'line_timeout', fallback='2.0') }}">
                    <small class="help-text">Time before clearing the serial buffer if 010 is not detected.</small>
                </div>
            </div>
            <!-- Sound Settings -->
            <div class="config-section">
                <h3>Sound Settings</h3>
                <div class="form-group">
                    <label for="sound_directory">Sound Directory:</label>
                    <input type="text" id="sound_directory" name="sound_directory" value="{{ config.get('Sound', 'directory', fallback='/home/drx/DRX/sounds/') }}">
                </div>
                <div class="form-group">
                    <label for="sound_extension">File Extension:</label>
                    <select id="sound_extension" name="sound_extension">
                        <option value=".wav" {% if config.get('Sound', 'extension', fallback='.wav') == '.wav' %}selected{% endif %}>.wav</option>
                        <option value=".mp3" {% if config.get('Sound', 'extension', fallback='.wav') == '.mp3' %}selected{% endif %}>.mp3</option>
                        <option value=".ogg" {% if config.get('Sound', 'extension', fallback='.wav') == '.ogg' %}selected{% endif %}>.ogg</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="sound_device">Sound Device:</label>
                    <input type="text" id="sound_device" name="sound_device" value="{{ config.get('Sound', 'device', fallback='plughw:2,0') }}">
                </div>
            </div>
            <!-- Web Authentication + Web Server (stacked in one card) -->
            <div class="config-section">
                <div class="split-vertical">
                    <div class="split-half">
                        <h3>Web Authentication</h3>
                        <div class="form-group">
                            <label for="web_username">Username:</label>
                            <input type="text" id="web_username" name="web_username" value="{{ config.get('WebAuth', 'username', fallback='k1sox') }}">
                        </div>
                        <div class="form-group">
                            <label for="web_password">Password:</label>
                            <input type="password" id="web_password" name="web_password" value="{{ config.get('WebAuth', 'password', fallback='') }}" placeholder="Enter new password or leave blank to keep current">
                        </div>
                    </div>
                    <div class="split-half">
                        <h3>Web Server</h3>
                        <div class="form-group">
                            <label for="web_port">Port Number:</label>
                            <input type="number" id="web_port" name="web_port" min="1" max="65535" value="{{ config.get('Web', 'port', fallback='505') }}">
                        </div>
                    </div>
                </div>
            </div>
            <!-- GPIO Settings: spans 4 columns and 2 rows -->
            <div class="config-section gpio-settings">
                <h3>GPIO Settings</h3>
                <div class="form-group">
                    <label for="remote_busy_pin">Remote Busy Pin:</label>
                    <input type="number" id="remote_busy_pin" name="remote_busy_pin" min="0" value="{{ config.get('GPIO', 'remote_busy_pin', fallback='20') }}">
                </div>
                <div class="form-group checkbox">
                    <input type="checkbox" id="remote_busy_activate_level" name="remote_busy_activate_level" {% if config.get('GPIO', 'remote_busy_activate_level', fallback='False').lower() == 'true' %}checked{% endif %}>
                    <label for="remote_busy_activate_level">Remote Device Busy Active High</label>
                </div>
                <hr style="background-color: blue;">
                <div class="form-group">
                    <label for="cos_pin">COS Pin:</label>
                    <input type="number" id="cos_pin" name="cos_pin" min="0" value="{{ config.get('GPIO', 'cos_pin', fallback='16') }}">
                </div>
                <div class="form-group checkbox">
                    <input type="checkbox" id="cos_activate_level" name="cos_activate_level" {% if config.get('GPIO', 'cos_activate_level', fallback='False').lower() == 'true' %}checked{% endif %}>
                    <label for="cos_activate_level">COS Active High</label>
                </div>
                <br>
                <div class="form-group">
                    <label for="cos_debounce_time">COS Debounce Time (seconds):</label>
                    <input type="number" id="cos_debounce_time" name="cos_debounce_time" min="0" step="0.1" value="{{ config.get('GPIO', 'cos_debounce_time', fallback='1.0') }}">
                </div>
                <div class="form-group">
                    <label for="max_cos_interruptions">Max COS Interruptions:</label>
                    <input type="number" id="max_cos_interruptions" name="max_cos_interruptions" min="0" value="{{ config.get('GPIO', 'max_cos_interruptions', fallback='3') }}">
                </div>
            </div>
        </div>
        <div style="margin-top: 12px; display: flex; justify-content: center;">
            <button type="submit" onclick="return confirm('Save configuration changes?')">Save Configuration</button>
        </div>
    </form>
</div>
<script>
document.addEventListener('DOMContentLoaded', function() {
    var select = document.querySelector('select[name="track_dropdown"]');
    if (select) {
        var longest = 0;
        for (var i = 0; i < select.options.length; i++) {
            var option = select.options[i];
            // Create a temporary span to measure text width
            var span = document.createElement('span');
            span.style.visibility = 'hidden';
            span.style.position = 'absolute';
            span.style.font = window.getComputedStyle(select).font;
            span.textContent = option.text;
            document.body.appendChild(span);
            if (span.offsetWidth > longest) longest = span.offsetWidth;
            document.body.removeChild(span);
        }
        // Add some padding for the dropdown arrow
        select.style.width = (longest + 24) + 'px';
    }
});
</script>
<!-- Base Configurator Modal -->
<div id="base-configurator-modal" class="modal">
  <div class="modal-content" style="max-width: 1200px;">
    <div id="base-configurator-modal-header" style="cursor:move; user-select:none;">
      <span class="close" id="close-base-configurator">&times;</span>
      <h2 style="display:inline-block; margin:0 0 0 10px;">Base Configurator</h2>
    </div>
    <small class="help-text">Hint: You can drag the columns to rearrange them. This window is draggable as well.</small>
    <br>
    <br>
    <!-- Add validation summary -->
    <div id="base-configurator-validation-summary"></div>
    
    <div id="base-configurator-table-section">
      <table id="base-configurator-table" style="width:100%; border-collapse:collapse;">
        <thead>
    <tr>
        <th style="width:60px; text-align:left; padding:4px;">Base No.</th>
        <th style="width:70px; text-align:left; padding:4px;">End No.</th>
        <th style="width:110px; text-align:left; padding:4px;">Type</th>
        <th style="width:90px; text-align:left; padding:4px;">Interval</th>
        <th style="text-align:left; padding:4px;">Description</th>
        <th style="width:90px;"></th>
    </tr>
        </thead>
        <tbody></tbody>
      </table>
      <button id="add-base-configurator-row" style="margin:10px 0 7px 0;">Add Row</button>
    </div>
    <div style="text-align:right;">
      <button id="save-base-configurator" style="font-weight:bold;">Save</button>
    </div>
    <div id="base-configurator-msg" style="margin-top:8px; color:#388e3c; font-size:1em;"></div>
  </div>
</div>
<script>
// --- Base Configurator Modal JS with Validation ---
document.addEventListener("DOMContentLoaded", function() {
    const configuratorBtn = document.getElementById('base-configurator-btn');
    const configuratorModal = document.getElementById('base-configurator-modal');
    const closeconfigurator = document.getElementById('close-base-configurator');
    const tableBody = document.querySelector('#base-configurator-table tbody');
    const addRowBtn = document.getElementById('add-base-configurator-row');
    const saveBtn = document.getElementById('save-base-configurator');
    const msgDiv = document.getElementById('base-configurator-msg');
    const validationSummary = document.getElementById('base-configurator-validation-summary');
    let dragSrcRow = null;

    // Open modal and load configurator
    if (configuratorBtn && configuratorModal && closeconfigurator) {
        configuratorBtn.onclick = function() {
            configuratorModal.style.display = "block";
            loadBaseConfigurator();
        };
        closeconfigurator.onclick = function() {
            configuratorModal.style.display = "none";
            msgDiv.textContent = "";
            clearValidationErrors();
        };
        window.onclick = function(event) {
            if (event.target == configuratorModal) {
                configuratorModal.style.display = "none";
                msgDiv.textContent = "";
                clearValidationErrors();
            }
        };
    }

    // Validation functions
    function parseNumber(str) {
        const num = parseInt(str.trim());
        return isNaN(num) ? null : num;
    }

    function rangesOverlap(range1, range2) {
        // range1 and range2 are objects with {start, end} where end might be null
        const r1Start = range1.start;
        const r1End = range1.end !== null ? range1.end : range1.start;
        const r2Start = range2.start;
        const r2End = range2.end !== null ? range2.end : range2.start;
        
        return r1Start <= r2End && r2Start <= r1End;
    }

function validateRanges() {
    const rows = tableBody.querySelectorAll("tr");
    const ranges = [];
    const validationErrors = [];
    
    // Clear previous errors
    clearValidationErrors();
    
    // Parse all ranges
    rows.forEach((tr, index) => {
        const baseInput = tr.children[0].querySelector("input");
        const endInput = tr.children[1].querySelector("input");
        const typeSelect = tr.children[2].querySelector("select");
        const intervalInput = tr.children[3].querySelector("input");
        
        const baseNo = parseNumber(baseInput.value);
        const endNo = parseNumber(endInput.value);
        const type = typeSelect.value;
        
        // 1. Validate that base and end numbers are 4 digits and not negative
        if (baseInput.value.trim() !== "") {
            if (!/^\d{1,4}$/.test(baseInput.value.trim())) {
                baseInput.classList.add('base-error');
                validationErrors.push(`Row ${index + 1}: Base number must be 1-4 digits and not negative`);
            } else if (baseInput.value.trim().length < 4) {
                // Pad with zeros for display purposes only (doesn't affect the saved value)
                baseInput.placeholder = baseInput.value.trim().padStart(4, '0');
            }
        }
        
        if (endInput.value.trim() !== "") {
            if (!/^\d{1,4}$/.test(endInput.value.trim())) {
                endInput.classList.add('base-error');
                validationErrors.push(`Row ${index + 1}: End number must be 1-4 digits and not negative`);
            } else if (endInput.value.trim().length < 4) {
                // Pad with zeros for display purposes only (doesn't affect the saved value)
                endInput.placeholder = endInput.value.trim().padStart(4, '0');
            }
        }
        
        // 2. Validate that type is selected
        if (type === "") {
            typeSelect.classList.add('base-error');
            validationErrors.push(`Row ${index + 1}: Type must be selected`);
        }
        
        // 3. Validate that end number is at least 2 greater than base number
        if (baseNo !== null && endNo !== null) {
            if (endNo - baseNo < 2) {
                endInput.classList.add('base-error');
                baseInput.classList.add('base-error');
                validationErrors.push(`Row ${index + 1}: End number must be at least 2 greater than base number`);
            }
        }
        
        if (baseNo !== null) {
            ranges.push({
                index: index,
                start: baseNo,
                end: endNo,
                baseInput: baseInput,
                endInput: endInput,
                row: tr
            });
        }
    });
    
    // Check for overlaps (existing validation)
    for (let i = 0; i < ranges.length; i++) {
        for (let j = i + 1; j < ranges.length; j++) {
            const range1 = ranges[i];
            const range2 = ranges[j];
            
            if (rangesOverlap(range1, range2)) {
                // Mark both ranges as errors
                range1.baseInput.classList.add('base-error');
                if (range1.endInput.value.trim()) {
                    range1.endInput.classList.add('base-error');
                }
                range2.baseInput.classList.add('base-error');
                if (range2.endInput.value.trim()) {
                    range2.endInput.classList.add('base-error');
                }
                
                const range1Desc = range1.end !== null ? 
                    `${range1.start}-${range1.end}` : `${range1.start}`;
                const range2Desc = range2.end !== null ? 
                    `${range2.start}-${range2.end}` : `${range2.start}`;
                
                validationErrors.push(
                    `Row ${range1.index + 1} (${range1Desc}) overlaps with Row ${range2.index + 1} (${range2Desc})`
                );
            }
        }
    }
    
    // Update UI based on validation results
    if (validationErrors.length > 0) {
        validationSummary.innerHTML = 
            '<strong>Validation Errors:</strong><br>' + 
            validationErrors.join('<br>');
        validationSummary.style.display = 'block';
        saveBtn.classList.add('save-disabled');
        saveBtn.disabled = true;
        return false;
    } else {
        validationSummary.style.display = 'none';
        saveBtn.classList.remove('save-disabled');
        saveBtn.disabled = false;
        return true;
    }
}

    function clearValidationErrors() {
    const inputs = tableBody.querySelectorAll('input, select');
    inputs.forEach(input => {
        input.classList.remove('base-error');
    });
    validationSummary.style.display = 'none';
    saveBtn.classList.remove('save-disabled');
    saveBtn.disabled = false;
}

    function makeRow(rowData = {base_no: "", end_no: "", type: "", interval: "", desc: ""}) {
        const tr = document.createElement("tr");
        tr.draggable = true;
        tr.style.cursor = "grab";

        const tdBase = document.createElement("td");
        const tdEnd = document.createElement("td");
        const tdType = document.createElement("td");
        const tdInterval = document.createElement("td");
        const tdDesc = document.createElement("td");
        const tdDel = document.createElement("td");

        // Base No. input
        const inputBase = document.createElement("input");
        inputBase.type = "text";
        inputBase.value = rowData.base_no || "";
        inputBase.placeholder = "Base No.";
        inputBase.className = "base-no";
        
        // Add validation on input
        inputBase.addEventListener('input', function() {
            setTimeout(validateRanges, 100); // Small delay to allow for rapid typing
        });
        
        tdBase.appendChild(inputBase);

        // End No. input
        const inputEnd = document.createElement("input");
        inputEnd.type = "text";
        inputEnd.value = rowData.end_no || "";
        inputEnd.placeholder = "End No.";
        inputEnd.className = "end-no";
        
        // Add validation on input
        inputEnd.addEventListener('input', function() {
            setTimeout(validateRanges, 100); // Small delay to allow for rapid typing
        });
        
        tdEnd.appendChild(inputEnd);

        // Type dropdown
        const selectType = document.createElement("select");
        selectType.className = "base-type";
        ["", "Rotating", "Random", "SudoRandom"].forEach(optVal => {
            const opt = document.createElement("option");
            opt.value = optVal;
            opt.textContent = optVal;
            if (rowData.type === optVal) opt.selected = true;
            selectType.appendChild(opt);
        });
        tdType.appendChild(selectType);

        // Interval input
        const inputInterval = document.createElement("input");
        inputInterval.type = "number";
        inputInterval.className = "base-interval";
        inputInterval.min = "0";
        inputInterval.step = "1";
        inputInterval.value = typeof rowData.interval !== "undefined" ? rowData.interval : "";
        inputInterval.placeholder = "0";
        tdInterval.appendChild(inputInterval);

        // Description input
        const inputDesc = document.createElement("input");
        inputDesc.type = "text";
        inputDesc.className = "base-desc";
        inputDesc.value = rowData.desc || "";
        inputDesc.placeholder = "Description";
        tdDesc.appendChild(inputDesc);

        // Delete button
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.type = "button";
        delBtn.onclick = function() { 
            tr.remove(); 
            setTimeout(validateRanges, 50); // Revalidate after deletion
        };
        tdDel.appendChild(delBtn);

        // --- DRAG AND DROP ROWS ---
        tr.addEventListener('dragstart', function (e) {
            dragSrcRow = tr;
            tr.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', '');
        });
        tr.addEventListener('dragover', function (e) {
            e.preventDefault();
            if (tr !== dragSrcRow) tr.classList.add('dragover');
        });
        tr.addEventListener('dragleave', function (e) {
            tr.classList.remove('dragover');
        });
        tr.addEventListener('drop', function (e) {
            e.preventDefault();
            tr.classList.remove('dragover');
            if (dragSrcRow && dragSrcRow !== tr) {
                const bounding = tr.getBoundingClientRect();
                const offset = e.clientY - bounding.top;
                if (offset < bounding.height / 2) {
                    tr.parentNode.insertBefore(dragSrcRow, tr);
                } else {
                    tr.parentNode.insertBefore(dragSrcRow, tr.nextSibling);
                }
                // Revalidate after reordering
                setTimeout(validateRanges, 50);
            }
            dragSrcRow = null;
        });
        tr.addEventListener('dragend', function (e) {
            tr.classList.remove('dragging');
            // Remove dragover from all rows
            const rows = tr.parentNode.querySelectorAll('tr');
            rows.forEach(row => row.classList.remove('dragover'));
            dragSrcRow = null;
        });
        // --- END DRAG AND DROP ROWS ---

        // Append in order
        tr.appendChild(tdBase);
        tr.appendChild(tdEnd);
        tr.appendChild(tdType);
        tr.appendChild(tdInterval);
        tr.appendChild(tdDesc);
        tr.appendChild(tdDel);
        return tr;
    }

    function loadBaseConfigurator() {
        fetch("/api/base_configurator", {credentials: 'same-origin'})
        .then(resp => resp.json())
        .then(data => {
            tableBody.innerHTML = "";
            (data || []).forEach(row => {
                tableBody.appendChild(makeRow(row));
            });
            // Validate after loading
            setTimeout(validateRanges, 100);
        });
    }

    if (addRowBtn) {
        addRowBtn.onclick = function() {
            tableBody.appendChild(makeRow());
            // Validate after adding (though new empty row shouldn't cause issues)
            setTimeout(validateRanges, 50);
        };
    }

    if (saveBtn) {
        saveBtn.onclick = function() {
            // Final validation before save
            if (!validateRanges()) {
                msgDiv.style.color = "#d32f2f";
                msgDiv.textContent = "Cannot save: Please resolve range overlaps first.";
                return;
            }
            
            // Gather data
            const rows = tableBody.querySelectorAll("tr");
            const configurator = [];
            for (let tr of rows) {
                const base_no = tr.children[0].querySelector("input").value.trim();
                const end_no = tr.children[1].querySelector("input").value.trim();
                const type = tr.children[2].querySelector("select").value;
                const interval = tr.children[3].querySelector("input").value.trim();
                const desc = tr.children[4].querySelector("input").value.trim();
                if (base_no || end_no || type || interval || desc) {
                    configurator.push({base_no, end_no, type, interval, desc});
                }
            }
            fetch("/api/save_base_configurator", {
                method: "POST",
                credentials: "same-origin",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify(configurator)
            })
            .then(resp => resp.json())
            .then(data => {
                if (data.success) {
                    msgDiv.style.color = "#388e3c";
                    msgDiv.textContent = "Configuration saved successfully.";
                    clearValidationErrors();
                } else {
                    msgDiv.style.color = "#d32f2f";
                    msgDiv.textContent = "Error saving configuration: " + (data.error || "Unknown error");
                }
            }).catch(e => {
                msgDiv.style.color = "#d32f2f";
                msgDiv.textContent = "Network or server error.";
            });
        };
    }
});
</script>
<script>
// Draggable modal logic
(function() {
  const modal = document.getElementById('base-configurator-modal');
  const header = document.getElementById('base-configurator-modal-header');
  let isDragging = false;
  let offsetX = 0;
  let offsetY = 0;

  header.addEventListener('mousedown', function(e) {
    isDragging = true;
    // Calculate offset
    const rect = modal.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;

    document.body.style.userSelect = 'none'; // Prevent text highlight

    document.onmousemove = function(e) {
      if (isDragging) {
        modal.style.position = 'fixed';
        modal.style.left = (e.clientX - offsetX) + 'px';
        modal.style.top = (e.clientY - offsetY) + 'px';
        modal.style.margin = 0; // Remove any margin
      }
    }

    document.onmouseup = function() {
      isDragging = false;
      document.onmousemove = null;
      document.onmouseup = null;
      document.body.style.userSelect = ''; // Re-enable text select
    }
  });
})();
</script>
<!-- Play Local Modal -->
<div id="play-local-modal" class="modal">
    <div class="modal-content">
        <span class="close" id="close-play-local">&times;</span>
        <h2 id="play-local-title">Playing Audio</h2>
        <audio id="play-local-audio" controls autoplay>
            <source id="play-local-source" src="" type="audio/wav">
            Your browser does not support the audio element.
        </audio>
        <br>
        <button id="play-local-close-btn" type="button">Close</button>
    </div>
</div>
</body>
</html>
'''

STATE_BLOCKS_TEMPLATE = '''
<h2>Rotation Bases State</h2>
<pre class="stateblock stateblock-1">{% for l in state.get('rotation_bases_lines', []) %}{{ l }}
{% endfor %}</pre>
<h2>Random Bases State</h2>
<pre class="stateblock stateblock-2">{% for l in state.get('random_bases_lines', []) %}{{ l }}
{% endfor %}</pre>
<h2>SudoRandom Bases State</h2>
<pre class="stateblock stateblock-3">{% for l in state.get('sudo_bases_lines', []) %}{{ l }}
{% endfor %}</pre>
<h2>Alternate-Series State</h2>
<pre class="stateblock stateblock-4">{% for l in state.get('alt_bases_lines', []) %}{{ l }}
{% endfor %}</pre>
'''

LOGIN_TEMPLATE = '''
<!doctype html>
<html>
<head>
<title>Login - DRX Dashboard</title>
<link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
<style>
body { font-family: 'Roboto', Arial, sans-serif; background: #f5f7fa; margin: 0; padding: 0; }
#login-card { background: #fff; max-width: 900px; margin: 80px auto 40px auto; border-radius: 16px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1); padding: 2.2em 2.5em 2em 2.5em; text-align: center;}
#logo-img { max-width: 60%; height: auto; display: block; margin: 0 auto 1.2em auto; border-radius: 10px; box-shadow: 0 2px 10px 0 rgba(31, 38, 135, 0.07);}
h1 { color: #3949ab; font-weight: 700; margin-bottom: 1.2em; text-align: center; letter-spacing: 1px;}
</style>
</head>
<body>
<div id="login-card">
<img id="logo-img" src="{{ url_for('static', filename='xpander.png') }}" alt="XPANDER Digital Repeater Logo">
<h1>DRX Dashboard Login</h1>
<form method="POST" action="{{ url_for('login') }}">
    <label>Username:</label>
    <input type="text" name="username" autofocus required>
    <label>Password:</label>
    <input type="password" name="password" required>
    <button type="submit">Login</button>
</form>
{% if error %}
<div class="error-msg">{{ error }}</div>
{% endif %}
</div>
</body>
</html>
'''

def get_all_sound_files():
    try:
        ext = SOUND_FILE_EXTENSION.lower()
        return sorted([f for f in os.listdir(SOUND_DIRECTORY) if f.lower().endswith(ext)])
    except Exception:
        return []

def get_config_file_content():
    try:
        with open(config_file_path, 'r') as f:
            return f.read()
    except Exception:
        return ""

def save_config_file(new_content):
    with open(config_file_path, 'w') as f:
        f.write(new_content)

def require_login(f):
    from functools import wraps
    @wraps(f)
    def decorated(*args, **kwargs):
        if not session.get('logged_in'):
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated

import sys  # Add this if not already there

# Add these variables at the top near your other imports
_state_cache = {}
_state_cache_time = 0
_state_cache_ttl = 0.1  # Cache valid for 100 ms

def read_state():
    """
    Fetch current state from drx_main.py via HTTP API instead of reading from file.
    Falls back to cached state if HTTP request fails.
    """
    global _state_cache, _state_cache_time
    
    # Return cached state if it's recent enough
    if time.time() - _state_cache_time < _state_cache_ttl and _state_cache:
        return _state_cache
    
    try:
        # Fetch state from drx_main.py HTTP API
        response = requests.get(DRX_MAIN_API_URL, timeout=HTTP_TIMEOUT)
        if response.status_code == 200:
            state = response.json()
            # Update cache
            _state_cache = state
            _state_cache_time = time.time()
            return state
        else:
            # HTTP error - return cached state if available
            return _state_cache if _state_cache else {}
    except requests.exceptions.RequestException:
        # Connection failed - drx_main.py might not be running
        # Return cached state if available, otherwise empty dict
        return _state_cache if _state_cache else {}
    except Exception:
        # Other error - return cached state if available
        return _state_cache if _state_cache else {}

def write_webcmd(cmd_dict):
    with open(WEBCMD_FILE, 'w') as f:
        json.dump(cmd_dict, f)

def wait_cmd_processed(timeout=3.0):
    for _ in range(int(timeout * 10)):
        if not os.path.exists(WEBCMD_FILE):
            return
        time.sleep(0.1)

import re

def load_recent_web_log(n=10):
    try:
        if not os.path.exists(LOG_FILE):
            return ["Log file not found."]
        with open(LOG_FILE, 'r') as f:
            lines = f.readlines()
            lines = [line.rstrip() for line in lines if line.strip()]
        if not lines:
            return ["Log file is empty."]
        
        # More precise regex that only targets timestamps (e.g., 2023-07-11 13:45:23.456)
        # This will look for dates/times and only remove milliseconds from them
        return [re.sub(r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\.\d{1,6}', r'\1', line) for line in lines[-n:]]
    except Exception as e:
        return [f"Error loading log: {e}"]

@app.route("/login", methods=["GET", "POST"])
def login():
    error = ""
    if request.method == "POST":
        username = request.form.get("username", "")
        password = request.form.get("password", "")
        if username == WEB_USER and password == WEB_PASS:
            session['logged_in'] = True
            session['username'] = username
            return redirect(url_for('dashboard'))
        else:
            error = "Invalid username or password."
    return render_template_string(LOGIN_TEMPLATE, error=error)

@app.route("/logout", methods=["POST"])
def logout():
    session.clear()
    return redirect(url_for('login'))

@app.route("/", methods=["GET"])
@require_login
def dashboard():
    # Reload config from file each time dashboard is loaded
    global config
    config = configparser.ConfigParser()
    config.read(config_file_path)
    
    state = read_state()
    wx_alert_active = state.get("wx_alert_active", False)
    state_blocks_html = render_template_string(STATE_BLOCKS_TEMPLATE, state=state)
    
    # --- Weather System Status ---
    weather_status, weather_class, weather_color = get_weather_system_status(wx_alert_active)
    
    return render_template_string(DASHBOARD_TEMPLATE,
        currently_playing=state.get("currently_playing"),
        last_played=state.get("last_played"),
        playback_status=state.get("playback_status"),
        cos_state="YES" if is_cos_active() else "NO",
        serial_port_missing=state.get("serial_port_missing", False),
        sound_card_missing=state.get("sound_card_missing", False),
        serial_history=state.get("serial_history", []),
        state=state,
        web_log=load_recent_web_log(10)[::-1],
        all_files=get_all_sound_files(),
        config=config,  # This will now be the freshly loaded config
        session=session,
        state_blocks_html=state_blocks_html,
        drx_uptime=get_drx_uptime(),
        weather_status=weather_status,
        weather_class=weather_class,
        weather_color=weather_color,
        version=state.get("version", "Unknown"),
        web_version="2.01.00"
    )
    
def is_cos_active():
    try:
        state = read_state()
        return state.get("cos_active", False)
    except Exception:
        return False

def get_drx_uptime():
    state = read_state()
    updated_at = state.get('updated_at')
    if not updated_at:
        return "drx_main.py Not Running!"
    if time.time() - float(updated_at) > 2.5:  # If no update in last 2.5 seconds
        return "drx_main.py Not Running!"
    start_time = state.get('drx_start_time')
    if not start_time:
        return "Unknown"
    uptime_seconds = int(time.time() - float(start_time))
    days, remainder = divmod(uptime_seconds, 86400)
    hours, remainder = divmod(remainder, 3600)
    minutes, seconds = divmod(remainder, 60)
    if days > 0:
        return f"{days}d {hours}h {minutes}m {seconds}s"
    elif hours > 0:
        return f"{hours}h {minutes}m {seconds}s"
    elif minutes > 0:
        return f"{minutes}m {seconds}s"
    else:
        return f"{seconds}s"

@app.route("/stop", methods=['POST'])
@require_login
def stop_playback():
    write_webcmd({"type": "stop"})
    wait_cmd_processed()
    return redirect(url_for('dashboard'))

@app.route("/playtrack", methods=['POST'])
@require_login
def play_track():
    track_dropdown = request.form.get("track_dropdown")
    track_input = request.form.get("track_input", "").strip()
    play_method = request.form.get("play_method", "normal")
    track = track_dropdown or track_input
    if not track:
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({"success": False, "error": "No track selected"})
        return redirect(url_for('dashboard'))

    if play_method == "local":
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            # Return filename directly for AJAX modal handling
            return jsonify({"success": True, "local_play": True, "filename": track})
        return redirect(url_for('play_local', filename=track))
    else:
        write_webcmd({"type": "play", "input": track})
        wait_cmd_processed()
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({"success": True})
        return redirect(url_for('dashboard'))

@app.route('/localplay/<filename>')
@require_login
def play_local(filename):
    # Always return JSON - no more separate page
    return jsonify({
        "success": True,
        "filename": filename,
        "audio_url": url_for('get_audio', filename=filename)
    })

@app.route('/audio/<filename>')
@require_login
def get_audio(filename):
    return send_from_directory(SOUND_DIRECTORY, filename)

@app.route("/restart", methods=['POST'])
@require_login
def restart_script_web():
    subprocess.run(["sudo", "systemctl", "restart", "drx_main"])
    return redirect(url_for('dashboard'))

@app.route("/reboot", methods=['POST'])
@require_login
def reboot_system_web():
    write_webcmd({"type": "reboot"})
    wait_cmd_processed()
    return redirect(url_for('dashboard'))

@app.route("/reloadconfig", methods=['POST'])
@require_login
def reload_config_web():
    # Send command to DRX script
    write_webcmd({"type": "reload_config"})
    wait_cmd_processed()
    
    # Also reload config in the web app
    global config
    config = configparser.ConfigParser()
    config.read(config_file_path)
    
    # Flash a message to confirm
    flash('Configuration reloaded!')
    
    return redirect(url_for('dashboard'))

@app.route("/editconfig", methods=['POST'])
@require_login
def edit_config():
    content = request.form.get("config_content", "")
    if content:
        save_config_file(content)
        write_webcmd({"type": "reload_config"})
        wait_cmd_processed()
    return redirect(url_for('dashboard'))

@app.route("/api/log_entries")
@require_login
def api_log_entries():
    entries = load_recent_web_log(50)[::-1]
    return render_template_string('''
        {% for entry in web_log %}
            <div>{{ entry }}</div>
        {% endfor %}
    ''', web_log=entries)

@app.route("/api/serial_commands")
@require_login
def api_serial_commands():
    state = read_state()
    serial_history = state.get("serial_history", [])
    def fmt(entry):
        ts = entry.get("ts", "")
        cmd = entry.get("cmd", "")
        src = entry.get("src", "Serial")
        return f"{ts}: {cmd} ({src})"
    formatted = [fmt(entry) for entry in serial_history[:5]]
    return render_template_string('''
        {% for line in formatted %}
            <div>{{ line }}</div>
        {% endfor %}
    ''', formatted=formatted)

@app.route("/api/state_blocks")
@require_login
def api_state_blocks():
    state = read_state()
    return render_template_string(STATE_BLOCKS_TEMPLATE, state=state)

@app.route("/api/drx_uptime")
@require_login
def api_drx_uptime():
    state = read_state()
    updated_at = state.get('updated_at')
    not_running = False
    if not updated_at or time.time() - float(updated_at) > 2.5:
        not_running = True
    return jsonify({
        'drx_uptime': get_drx_uptime(),
        'not_running': not_running,
    })

@app.route("/api/message_timer")
@require_login
def api_message_timer():
    state = read_state()
    last_played = state.get("message_timer_last_played", 0)
    timer_value = state.get("message_timer_value", 0)
    now = time.time()
    if last_played and timer_value:
        seconds_left = int(max(0, timer_value * 60 - (now - last_played)))
    else:
        seconds_left = 0
    return jsonify({"seconds_left": seconds_left})

@app.route("/editconfig_structured", methods=['POST'])
@require_login
def edit_config_structured():
    # Read the existing config to preserve structure
    existing_config = configparser.ConfigParser()
    existing_config.read(config_file_path)
    
    # Get form data
    form_data = request.form.to_dict()
    
    # Update Serial section
    if 'Serial' not in existing_config:
        existing_config['Serial'] = {}
    existing_config['Serial']['port'] = form_data.get('serial_port', '/dev/ttyUSB0')
    existing_config['Serial']['baudrate'] = form_data.get('serial_baudrate', '57600')
    existing_config['Serial']['timeout'] = form_data.get('serial_timeout', '0.5')
    existing_config['Serial']['line_timeout'] = form_data.get('serial_line_timeout', '2.0')
    
    # Update Sound section
    if 'Sound' not in existing_config:
        existing_config['Sound'] = {}
    existing_config['Sound']['directory'] = form_data.get('sound_directory', '/home/drx/DRX/sounds/')
    existing_config['Sound']['extension'] = form_data.get('sound_extension', '.wav')
    existing_config['Sound']['device'] = form_data.get('sound_device', 'plughw:2,0')
    
    # Update General section
    if 'General' not in existing_config:
        existing_config['General'] = {}
    existing_config['General']['Message Timer'] = form_data.get('message_timer', '10')
     
    # Update GPIO section
    if 'GPIO' not in existing_config:
        existing_config['GPIO'] = {}
    existing_config['GPIO']['cos_pin'] = form_data.get('cos_pin', '16')
    existing_config['GPIO']['cos_activate_level'] = 'True' if form_data.get('cos_activate_level') else 'False'
    existing_config['GPIO']['remote_busy_pin'] = form_data.get('remote_busy_pin', '20')
    existing_config['GPIO']['remote_busy_activate_level'] = 'True' if form_data.get('remote_busy_activate_level') else 'False'
    existing_config['GPIO']['cos_debounce_time'] = form_data.get('cos_debounce_time', '1.0')
    existing_config['GPIO']['max_cos_interruptions'] = form_data.get('max_cos_interruptions', '3')
        
    # Update WebAuth section
    if 'WebAuth' not in existing_config:
        existing_config['WebAuth'] = {}
    existing_config['WebAuth']['username'] = form_data.get('web_username', 'k1sox')
    if form_data.get('web_password'):
        existing_config['WebAuth']['password'] = form_data.get('web_password')
    
    # Update Web section
    if 'Web' not in existing_config:
        existing_config['Web'] = {}
    existing_config['Web']['port'] = form_data.get('web_port', '505')
    
    # Update Debug section
    if 'Debug' not in existing_config:
        existing_config['Debug'] = {}
    existing_config['Debug']['enable_cos_override'] = 'true' if form_data.get('enable_cos_override') else 'false'
    existing_config['Debug']['enable_debug_logging'] = 'true' if form_data.get('enable_debug_logging') else 'false'
    
    # Write to file
    with open(config_file_path, 'w') as configfile:
        existing_config.write(configfile)
    
    # Use the simpler approach for telling DRX to reload
    write_webcmd({"type": "reload_config"})
    wait_cmd_processed()
    
    flash('Configuration updated successfully!')
    return redirect(url_for('dashboard'))

@app.route("/api/status")
@require_login
def status_api():
    # Update TOT state (check for timeout)
    update_tot_state()
    
    state = read_state()
    
    # Check if connection to drx_main.py is lost
    connection_lost = False
    updated_at = state.get('updated_at')
    if not updated_at or time.time() - float(updated_at) > 2.5:  # No update in 2.5 seconds
        connection_lost = True
        # Simulate receipt of TOP command when connection is lost
        # This will reset TOT to "completed" state rather than just inactive
        handle_top_command_on_disconnect()
    
    # Check recent serial commands for TOT/TOP
    if not connection_lost:  # Only process commands if connection is active
        serial_history = state.get("serial_history", [])
        for entry in serial_history[-10:]:  # Check last 10 commands
            cmd = entry.get("cmd", "").upper().strip()
            if process_serial_command_for_tot(cmd):
                break  # Stop after first relevant command found
    
    data = {
        "currently_playing": state.get("currently_playing"),
        "last_played": state.get("last_played"),
        "playback_status": state.get("playback_status"),
        "cos_state": False if connection_lost else is_cos_active(),  # COS inactive if disconnected
        "serial_port_missing": state.get("serial_port_missing", False),
        "sound_card_missing": state.get("sound_card_missing", False),
        "remote_device_active": state.get("remote_device_active", False),
        "tot_active": TOT_STATE['active'],  # This will now reflect the "TOP processed" state
        "tot_completed": TOT_STATE.get('completed', False)  # Include completed state if it exists
    }
    return jsonify(data)

# Add this new function to simulate TOP command processing on disconnect
def handle_top_command_on_disconnect():
    global TOT_STATE
    # Only process if TOT is currently active
    if TOT_STATE.get('active', False):
        # Set TOT to completed state (similar to what TOP would do)
        TOT_STATE['active'] = False
        TOT_STATE['completed'] = True
        TOT_STATE['end_time'] = time.time()
        # If you have a function that processes TOP commands, call it here:
        # process_top_command()
        
        # Log the automatic TOP action
        log_recent("Connection to drx_main.py lost - TOT automatically reset to completed state")

@app.route("/debug/ping")
def debug_ping():
    return jsonify({
        "time": time.time(),
        "formatted_time": time.strftime("%Y-%m-%d %H:%M:%S"),
        "success": True
    })

@app.route("/debug/webcmd_test")
@require_login
def debug_webcmd_test():
    try:
        # Create test command
        test_cmd = {"type": "test_command", "timestamp": time.time()}
        write_webcmd(test_cmd)
        
        # Wait a bit
        time.sleep(0.5)
        
        # Check if file still exists
        file_exists = os.path.exists(WEBCMD_FILE)
        
        return jsonify({
            "test_sent": True,
            "file_still_exists": file_exists,
            "current_time": time.strftime("%Y-%m-%d %H:%M:%S")
        })
    except Exception as e:
        return jsonify({"error": str(e)})

@app.route("/debug/config_values")
@require_login
def debug_config_values():
    # Reload config
    test_config = configparser.ConfigParser()
    test_config.read(config_file_path)
    
    # Get a few sample values
    sample_values = {
        "sound_directory": test_config.get('Sound', 'directory', fallback='Not found'),
        "web_port": test_config.get('Web', 'port', fallback='Not found'),
        "rotation_base": test_config.get('Rotation', 'base', fallback='Not found')
    }
    
    return jsonify({
        "config_path": config_file_path,
        "config_exists": os.path.exists(config_file_path),
        "sample_values": sample_values,
        "read_time": time.strftime("%Y-%m-%d %H:%M:%S")
    })

@app.route("/reset_minutes", methods=["POST"])
@require_login
def reset_minutes():
    # Send a reset command to DRX
    write_webcmd({"type": "reset_minutes"})
    wait_cmd_processed()
    return redirect(url_for('dashboard'))

@app.route("/api/cos_minutes")
@require_login
def api_cos_minutes():
    state = read_state()
    return jsonify({
        "cos_today_minutes": state.get("cos_today_minutes", 0),
        "cos_today_date": state.get("cos_today_date", "")
    })

@app.route("/api/dtmf_log")
def api_dtmf_log():
    n = 100  # Number of lines
    try:
        if not os.path.exists(DTMF_LOG_FILE):
            return "<div>No DTMF log entries found.</div>"
        with open(DTMF_LOG_FILE, "r") as f:
            lines = [line.rstrip() for line in f.readlines() if line.strip()]
        lines = lines[:n]
    except Exception as e:
        lines = [f"Error loading DTMF log: {e}"]
    return render_template_string('''
        {% for entry in dtmf_log %}
            <div>{{ entry }}</div>
        {% endfor %}
    ''', dtmf_log=lines)

# ... all your existing code above ...

@app.route("/download_dtmf_log")
@require_login
def download_dtmf_log():
    # DTMF log is stored in the same directory as this script.
    if not os.path.exists(DTMF_LOG_FILE):
        return "No DTMF log file.", 404
    return send_from_directory(
        os.path.dirname(DTMF_LOG_FILE),
        os.path.basename(DTMF_LOG_FILE),
        as_attachment=True
    )

def get_weather_system_status():
    wx_dir = os.path.join(os.path.dirname(__file__), "wx")
    wx_gen = os.path.join(wx_dir, "wx_gen.py")
    wx_data = os.path.join(wx_dir, "wx_data")
    if not os.path.exists(wx_gen):
        return ("Not Installed", "status-warn", "#888")
    if not os.path.exists(wx_data):
        return ("Inactive", "status-bad", "#d32f2f")
    mtime = os.path.getmtime(wx_data)
    if time.time() - mtime > 7200:
        return ("Inactive", "status-bad", "#d32f2f")
    return ("Active", "status-good", "#388e3c")

@app.route("/download_drx_log")
@require_login
def download_drx_log():
    # DRX log is stored in the LOG_FILE location
    if not os.path.exists(LOG_FILE):
        return "No DRX log file.", 404
    return send_from_directory(
        os.path.dirname(LOG_FILE),
        os.path.basename(LOG_FILE),
        as_attachment=True
    )

def load_base_configurator_from_ini():
    config = configparser.ConfigParser()
    config.read(config_file_path)
    # Build per-type row lists
    type_to_rows = {}
    for section, type_name in CONFIG_TYPES:
        if section not in config:
            type_to_rows[type_name] = []
            continue
        bases = config[section].get("base", "").split(",")
        ends = config[section].get("end", "").split(",")
        intervals = config[section].get("interval", "").split(",")
        descs = config[section].get("description", "").split(",") if "description" in config[section] else [""] * len(bases)
        max_len = max(len(bases), len(ends), len(intervals), len(descs))
        rows = []
        for i in range(max_len):
            rows.append({
                "base_no": bases[i].strip() if i < len(bases) else "",
                "end_no": ends[i].strip() if i < len(ends) else "",
                "interval": intervals[i].strip() if i < len(intervals) else "",
                "desc": descs[i].strip() if i < len(descs) else "",
                "type": type_name,
            })
        type_to_rows[type_name] = rows
    # Now, reorder according to [BaseOrder]
    order_section = config["BaseOrder"] if "BaseOrder" in config else {}
    order = order_section.get("order", "")
    if order:
        rows = []
        indices = {type_name: 0 for _, type_name in CONFIG_TYPES}
        # Parse order keys, e.g., "Rotating:0,Random:1"
        for entry in order.split(","):
            if ':' in entry:
                t, i_str = entry.split(':', 1)
                i = int(i_str)
                if t in type_to_rows and i < len(type_to_rows[t]):
                    rows.append(type_to_rows[t][i])
        return rows
    else:
        # Fallback: concat in legacy grouped order
        rows = []
        for _, type_name in CONFIG_TYPES:
            rows.extend(type_to_rows[type_name])
        return rows

def save_base_configurator_to_ini(rows):
    config = configparser.ConfigParser()
    config.read(config_file_path)
    # Clear out old values
    for section, _ in CONFIG_TYPES:
        if section not in config:
            config[section] = {}
        config[section]["base"] = ""
        config[section]["end"] = ""
        config[section]["interval"] = ""
        config[section]["description"] = ""
    # Group rows by type
    type_to_rows = {type_name: [] for _, type_name in CONFIG_TYPES}
    for row in rows:
        type_to_rows.get(row.get("type"), []).append(row)

    # Write grouped data as before
    for section, type_name in CONFIG_TYPES:
        group = type_to_rows[type_name]
        if group:
            config[section]["base"] = ",".join(r.get("base_no", "") for r in group)
            config[section]["end"] = ",".join(r.get("end_no", "") for r in group)
            config[section]["interval"] = ",".join(r.get("interval", "") for r in group)
            config[section]["description"] = ",".join(r.get("desc", "") for r in group)

    # Create [BaseOrder] section
    if "BaseOrder" not in config:
        config["BaseOrder"] = {}
    # For each row, store which type and its index in that type group
    type_indices = {type_name: 0 for _, type_name in CONFIG_TYPES}
    order_entries = []
    for row in rows:
        t = row.get("type")
        idx = type_indices[t]
        order_entries.append(f"{t}:{idx}")
        type_indices[t] += 1
    config["BaseOrder"]["order"] = ",".join(order_entries)

    # Write to file
    with open(config_file_path, 'w') as f:
        config.write(f)
    # Reload
    write_webcmd({"type": "reload_config"})
    wait_cmd_processed()

def update_tot_state():
    """Check if TOT should be reset due to timeout"""
    global TOT_STATE
    if TOT_STATE['active'] and TOT_STATE['start_time']:
        if time.time() - TOT_STATE['start_time'] > TOT_STATE['timeout_duration']:
            TOT_STATE['active'] = False
            TOT_STATE['start_time'] = None
            return True  # State changed
    return False

import re

def process_serial_command_for_tot(command):
    """Process serial commands to track TOT/TOP state"""
    global TOT_STATE
    command_upper = command.upper().strip()
    
    # Use regex to find TOT or TOP as whole words
    # This pattern looks for TOT or TOP surrounded by word boundaries
    tot_match = re.search(r'\bTOT\b', command_upper)
    top_match = re.search(r'\bTOP\b', command_upper)
    
    if tot_match and not top_match:
        # Found TOT as a whole word
        TOT_STATE['active'] = True
        TOT_STATE['start_time'] = time.time()
        return True  # State changed
    elif top_match:
        # Found TOP as a whole word
        TOT_STATE['active'] = False
        TOT_STATE['start_time'] = None
        return True  # State changed
    
    return False  # No state change

def get_weather_system_status(wx_alert_active=False):
    wx_dir = os.path.join(os.path.dirname(__file__), "wx")
    wx_gen = os.path.join(wx_dir, "wx_gen.py")
    wx_data = os.path.join(wx_dir, "wx_data")
    if wx_alert_active:
        return ("Alert", "status-alert", "#ff2222")
    if not os.path.exists(wx_gen):
        return ("Not Installed", "status-warn", "#888")
    if not os.path.exists(wx_data):
        return ("Inactive", "status-bad", "#d32f2f")
    mtime = os.path.getmtime(wx_data)
    if time.time() - mtime > 7200:
        return ("Inactive", "status-bad", "#d32f2f")
    return ("Active", "status-good", "#388e3c")

@app.route("/api/base_configurator", methods=["GET"])
def api_base_configurator():
    rows = load_base_configurator_from_ini()
    return jsonify(rows)

@app.route("/api/save_base_configurator", methods=["POST"])
@require_login
def api_save_base_configurator():
    try:
        rows = request.json or []
        save_base_configurator_to_ini(rows)
        return jsonify({"success": True})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

@app.route("/debug/state_source")
@require_login
def debug_state_source():
    """Debug endpoint to show how state is being fetched."""
    try:
        # Test HTTP API connection
        try:
            import requests
            response = requests.get(DRX_MAIN_API_URL, timeout=HTTP_TIMEOUT)
            api_status = {
                "reachable": True,
                "status_code": response.status_code,
                "response_size": len(response.content) if response.content else 0
            }
            if response.status_code == 200:
                api_data = response.json()
                api_status["data_keys"] = list(api_data.keys()) if isinstance(api_data, dict) else "not_dict"
        except Exception as e:
            api_status = {
                "reachable": False,
                "error": str(e)
            }
        
        # Check if old state file exists (for reference)
        file_status = {
            "exists": os.path.exists(STATE_FILE),
            "note": "File-based state is no longer used - state comes from HTTP API"
        }
        if file_status["exists"]:
            file_stats = os.stat(STATE_FILE)
            file_status.update({
                "size": file_stats.st_size,
                "modified": time.ctime(file_stats.st_mtime)
            })
        
        return jsonify({
            "state_source": "HTTP API from drx_main.py",
            "api_url": DRX_MAIN_API_URL,
            "api_status": api_status,
            "old_state_file": file_status,
            "cache_info": {
                "cache_ttl": _state_cache_ttl,
                "cache_size": len(str(_state_cache)) if _state_cache else 0,
                "cache_age": time.time() - _state_cache_time
            }
        })
    except Exception as e:
        return jsonify({"error": str(e)})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=WEB_PORT, debug=False, use_reloader=False)
