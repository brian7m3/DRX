#!/usr/bin/env python3

import os
import sys
import time
import threading
import configparser
import serial
import curses
import subprocess
import random
import re
import RPi.GPIO as GPIO#!/usr/bin/env python3

import os
import sys
import time
import threading
import configparser
import serial
import curses
import subprocess
import random
import re
import RPi.GPIO as GPIO
import datetime
import traceback
import wave
import contextlib
import shutil
import itertools
import json
import string
import os
import time
import datetime

# Get the directory where the script is located
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DEBUG_LOG_PATH = os.path.join(SCRIPT_DIR, "debug.log")

def debug_log(msg):
    if not ENABLE_DEBUG_LOGGING:
        return
    with open(DEBUG_LOG_PATH, 'a') as f:
        f.write(msg + '\n')

SCRIPT_NAME = "DRX"
VERSION = "2.02"

STATE_FILE = '/tmp/drx_state.json'
WEBCMD_FILE = '/tmp/drx_webcmd.json'
LOG_WEB_FILE = '/tmp/drx_webconsole.log'

serial_buffer = ""
serial_history = []
currently_playing = ""
currently_playing_info = ""
currently_playing_info_timestamp = 0
playing_end_time = 0
playback_status = ""
rotation_active = {}

serial_port_missing = False
sound_card_missing = False
playback_lock = threading.Lock()
remote_device_active = False
cos_active = False
DRX_START_TIME = time.time()
script_dir = os.path.dirname(os.path.realpath(__file__))
config_file_path = os.path.join(script_dir, 'config.ini')
log_file_path = os.path.join(script_dir, 'drx_error.log')
alternate_series_pointers = {}         # key: tuple(bases), value: current pointer/index (which base to play next)
alternate_series_track_pointers = {}   # key: tuple(bases), value: dict of base -> current track index (starts at 1)
alternate_series_last_played = {}      # key: tuple(bases), value: dict of base -> last_played_time

# --- Config Loading & Validation ---
DEFAULTS = {
    "Sound": {
        "directory": "/tmp/sounds",
        "extension": ".wav",
        "device": "default"
    },
    "GPIO": {
        "cos_pin": 23,
        "cos_activate_level": True,
        "remote_busy_pin": 25,
        "remote_busy_activate_level": True,
        "cos_debounce_time": 0.5,
        "max_cos_interruptions": 3
    },
    "Serial": {
        "port": "/dev/ttyUSB0",
        "baudrate": 9600,
        "timeout": 0.5
    },
    "Random": {
        "base": "3000",
        "end": "3099",
        "interval": "10"
    },
    "Rotation": {
        "base": "4000",
        "end": "4099",
        "time": "10"
    },
    "SudoRandom": {
        "base": "5000",
        "end": "5099",
        "interval": "10"
    },
    "Direct": {
        "enabled": "true",
        "prefix": "P"
    }
}
config_warnings = []

def get_config_value(section, key, fallback=None, cast_func=None, warn=None):
    global config_warnings
    if not config.has_section(section):
        config_warnings.append(f"Section [{section}] missing; using defaults.")
        val = DEFAULTS[section][key] if section in DEFAULTS and key in DEFAULTS[section] else fallback
        return cast_func(val) if cast_func else val
    if not config.has_option(section, key):
        config_warnings.append(f"Missing {key} in [{section}]; using default '{DEFAULTS.get(section, {}).get(key, fallback)}'.")
        val = DEFAULTS[section][key] if section in DEFAULTS and key in DEFAULTS[section] else fallback
        return cast_func(val) if cast_func else val
    raw = config[section][key]
    try:
        return cast_func(raw) if cast_func else raw
    except Exception as e:
        config_warnings.append(f"Invalid value for {key} in [{section}]: '{raw}' ({e}); using default '{DEFAULTS.get(section, {}).get(key, fallback)}'.")
        val = DEFAULTS[section][key] if section in DEFAULTS and key in DEFAULTS[section] else fallback
        return cast_func(val) if cast_func else val

def read_state():
    try:
        with open(STATE_FILE, 'r') as f:
            return json.load(f)
    except Exception:
        return {}

def parse_int_list(s, fallback=10, label="", section=""):
    vals = []
    for i, v in enumerate(s.split(',')):
        try:
            if float(v) != int(float(v)):
                config_warnings.append(f"{label} in [{section}]: '{v}' not integer, using {fallback}.")
                vals.append(int(fallback))
            else:
                vals.append(int(float(v)))
        except Exception:
            config_warnings.append(f"{label} in [{section}]: '{v}' invalid, using {fallback}.")
            vals.append(int(fallback))
    return vals

def parse_float_list(s, fallback=10, label="", section=""):
    vals = []
    for i, v in enumerate(s.split(',')):
        try:
            f = float(v)
            if f < 1:
                config_warnings.append(f"{label} in [{section}]: '{v}' < 1, using {fallback}.")
                f = float(fallback)
            elif f != int(f):
                config_warnings.append(f"{label} in [{section}]: '{v}' not integer, using {fallback}.")
                f = float(fallback)
            vals.append(int(f))
        except Exception:
            config_warnings.append(f"{label} in [{section}]: '{v}' invalid, using {fallback}.")
            vals.append(int(fallback))
    return vals

def match_code_file(f, code_str, ext):
    ext = ext.lower()
    f_lower = f.lower()
    # Only matches 5300.wav and 5300-xxxx.wav, not 5300.foo.wav or 5300anything.wav
    return (
        f_lower == f"{code_str}{ext}" or
        (f_lower.startswith(f"{code_str}-") and f_lower.endswith(ext))
    )

config = configparser.ConfigParser()
config_ini_missing = False
try:
    found_files = config.read(config_file_path)
    if not found_files:
        config_ini_missing = True
        config_warnings.insert(0, f"config.ini missing at {config_file_path}; using all default values.")
except Exception as e:
    config_ini_missing = True
    config_warnings.insert(0, f"Failed to read config.ini: {e}; using all default values.")

ENABLE_DEBUG_LOGGING = get_config_value("Debug", "enable_debug_logging", "false", lambda x: str(x).lower() in ("1", "true", "yes"))

SOUND_DIRECTORY = get_config_value("Sound", "directory", DEFAULTS["Sound"]["directory"])
SOUND_FILE_EXTENSION = get_config_value("Sound", "extension", DEFAULTS["Sound"]["extension"])
SOUND_DEVICE = get_config_value("Sound", "device", DEFAULTS["Sound"]["device"])

COS_PIN = get_config_value("GPIO", "cos_pin", DEFAULTS["GPIO"]["cos_pin"], int)
COS_ACTIVE_LEVEL = get_config_value("GPIO", "cos_activate_level", DEFAULTS["GPIO"]["cos_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
REMOTE_BUSY_PIN = get_config_value("GPIO", "remote_busy_pin", DEFAULTS["GPIO"]["remote_busy_pin"], int)
REMOTE_BUSY_ACTIVE_LEVEL = get_config_value("GPIO", "remote_busy_activate_level", DEFAULTS["GPIO"]["remote_busy_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
COS_DEBOUNCE_TIME = get_config_value("GPIO", "cos_debounce_time", DEFAULTS["GPIO"]["cos_debounce_time"], float)
MAX_COS_INTERRUPTIONS = get_config_value("GPIO", "max_cos_interruptions", DEFAULTS["GPIO"]["max_cos_interruptions"], int)

SERIAL_PORT = get_config_value("Serial", "port", DEFAULTS["Serial"]["port"])
SERIAL_BAUDRATE = get_config_value("Serial", "baudrate", DEFAULTS["Serial"]["baudrate"], int)
SERIAL_TIMEOUT = get_config_value("Serial", "timeout", DEFAULTS["Serial"]["timeout"], float)

RANDOM_BASE = get_config_value("Random", "base", DEFAULTS["Random"]["base"])
RANDOM_END = get_config_value("Random", "end", DEFAULTS["Random"]["end"])
RANDOM_INTERVAL = get_config_value("Random", "interval", DEFAULTS["Random"]["interval"])
ROTATION_BASE = get_config_value("Rotation", "base", DEFAULTS["Rotation"]["base"])
ROTATION_END = get_config_value("Rotation", "end", DEFAULTS["Rotation"]["end"])
ROTATION_TIME = get_config_value("Rotation", "time", DEFAULTS["Rotation"]["time"])
SUDORANDOM_BASE = get_config_value("SudoRandom", "base", DEFAULTS["SudoRandom"]["base"])
SUDORANDOM_END = get_config_value("SudoRandom", "end", DEFAULTS["SudoRandom"]["end"])
SUDORANDOM_INTERVAL = get_config_value("SudoRandom", "interval", DEFAULTS["SudoRandom"]["interval"])
DIRECT_ENABLED = get_config_value("Direct", "enabled", DEFAULTS["Direct"]["enabled"], lambda x: str(x).lower() in ("1", "true", "yes"))
DIRECT_PREFIX = get_config_value("Direct", "prefix", DEFAULTS["Direct"]["prefix"])

random_bases = parse_int_list(RANDOM_BASE, fallback=3000, label="Random base", section="Random")
random_ends = parse_int_list(RANDOM_END, fallback=3099, label="Random end", section="Random")
random_intervals = parse_float_list(RANDOM_INTERVAL, fallback=10, label="Random interval", section="Random")
rotation_bases = parse_int_list(ROTATION_BASE, fallback=4000, label="Rotation base", section="Rotation")
rotation_ends = parse_int_list(ROTATION_END, fallback=4099, label="Rotation end", section="Rotation")
rotation_times = parse_float_list(ROTATION_TIME, fallback=10, label="Rotation time", section="Rotation")
sudo_bases = parse_int_list(SUDORANDOM_BASE, fallback=5000, label="SudoRandom base", section="SudoRandom")
sudo_ends = parse_int_list(SUDORANDOM_END, fallback=5099, label="SudoRandom end", section="SudoRandom")
sudo_intervals = parse_float_list(SUDORANDOM_INTERVAL, fallback=10, label="SudoRandom interval", section="SudoRandom")

def validate_config_pairs():
    for bases, ends, label, section in [
        (random_bases, random_ends, "Random", "Random"),
        (rotation_bases, rotation_ends, "Rotation", "Rotation"),
        (sudo_bases, sudo_ends, "SudoRandom", "SudoRandom")
    ]:
        for i, (b, e) in enumerate(zip(bases, ends)):
            if e < b:
                config_warnings.append(f"{label} config: End {e} < Base {b} (index {i})")
validate_config_pairs()
# --------------------------------------------------

GPIO.setmode(GPIO.BCM)
GPIO.setup(REMOTE_BUSY_PIN, GPIO.OUT)
GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
GPIO.setup(COS_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

try:
    serial_port = serial.Serial(
        port=SERIAL_PORT,
        baudrate=SERIAL_BAUDRATE,
        timeout=SERIAL_TIMEOUT
    )
    serial_port.reset_input_buffer()
except Exception as e:
    serial_port = None
    serial_port_missing = True

random_last_played = {}
random_current_track = {}
rotation_last_played = {}
rotation_current_track = {}

sudo_random_last_interval = {}
sudo_random_interval_track = {}
sudo_random_played_in_cycle = {}
sudo_random_last_file = {}

playback_interrupt = threading.Event()
alternate_sequences = {}

def log_error(msg):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        with open(log_file_path, 'a') as f:
            f.write(f"[{timestamp}] {msg}\n")
    except Exception:
        print(f"[{timestamp}] Logging failed: {msg}")

def log_exception(context: str):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    exc = traceback.format_exc()
    try:
        with open(log_file_path, 'a') as f:
            f.write(f"[{timestamp}] Exception in {context}:\n{exc}\n")
    except Exception:
        print(f"[{timestamp}] Logging failed: {exc}")

def log_recent(entry):
    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
    try:
        with open(LOG_WEB_FILE, "a") as f:
            f.write(f"{ts}: {entry}\n")
        # --- TRIM LOG FILE IF OVER 500 KB ---
        max_size = 500 * 1024  # 500 KB
        try:
            if os.path.getsize(LOG_WEB_FILE) > max_size:
                with open(LOG_WEB_FILE, "rb") as f:
                    f.seek(-max_size, os.SEEK_END)
                    data = f.read()
                # find first newline to avoid splitting a line
                first_nl = data.find(b'\n')
                if first_nl != -1:
                    data = data[first_nl+1:]
                with open(LOG_WEB_FILE, "wb") as f:
                    f.write(data)
        except Exception as e:
            pass  # If trimming fails, just ignore
    except Exception as e:
        log_error(f"log_recent failed: {e}")

if shutil.which("sox") is None:
    log_error("sox is not installed! 'P' mode will not work.")

def is_cos_active():
    override_enabled = config.getboolean('Debug', 'enable_cos_override', fallback=False) if config.has_section('Debug') else False
    override_path = "/tmp/cos_force"
    if override_enabled:
        try:
            with open(override_path, "r") as f:
                val = f.read().strip()
                if val == "1":
                    return True
                elif val == "0":
                    return False
        except FileNotFoundError:
            pass
        except Exception:
            log_exception("is_cos_active (override)")
    try:
        level = GPIO.input(COS_PIN)
        return (level == COS_ACTIVE_LEVEL)
    except Exception:
        log_exception("is_cos_active (GPIO.input)")
        return False

def is_remote_device_active():
    try:
        level = GPIO.input(REMOTE_BUSY_PIN)
        return (level == REMOTE_BUSY_ACTIVE_LEVEL)
    except Exception:
        log_exception("is_remote_device_active (GPIO.input)")
        return False

def parse_suffix_first(cmd):
    valid_suffixes = {'I', 'R', 'P'}
    for idx, c in enumerate(cmd):
        if c in valid_suffixes:
            return cmd[:idx], c
    return cmd, None

def parse_alternate_series(cmd):
    """
    Parse commands like:
      'P5985A5299i5305'
      'P5985A5299'
      'P1234A5678I'
      'P1234A5678R'
    Returns:
      bases: list of int base codes (e.g., [5985, 5299])
      alt_suffix: str (e.g., 'i5305', 'I', 'R', etc) or None
      is_alt: True if alternate syntax detected
    """
    cmd = cmd.strip()
    # Match: P<base1>(A<base2>)+[suffix]
    m = re.match(r'^P(\d{4})(A\d{4})+([A-Z0-9]*)$', cmd, re.IGNORECASE)
    if not m:
        # Try to match with arbitrary suffix (e.g., i5305)
        m2 = re.match(r'^P(\d{4})(A\d{4})+(.*)$', cmd, re.IGNORECASE)
        if not m2:
            return [], None, False
        # Get all bases
        bases = [int(m2.group(1))]
        for match in re.finditer(r'A(\d{4})', cmd, re.IGNORECASE):
            bases.append(int(match.group(1)))
        # Suffix is whatever comes after the last Axxxx
        after_bases = re.sub(r'^P\d{4}(A\d{4})+', '', cmd, flags=re.IGNORECASE)
        alt_suffix = after_bases if after_bases else None
        return bases, alt_suffix, True

    # Get all bases
    bases = [int(m.group(1))]
    for match in re.finditer(r'A(\d{4})', cmd, re.IGNORECASE):
        bases.append(int(match.group(1)))
    alt_suffix = m.group(3) if m.group(3) else None
    return bases, alt_suffix, True

def get_base_type_and_info(base):
    for bases, ends, intervals, typ in [
        (random_bases, random_ends, random_intervals, 'Random'),
        (rotation_bases, rotation_ends, rotation_times, 'Rotation'),
        (sudo_bases, sudo_ends, sudo_intervals, 'SudoRandom')
    ]:
        if base in bases:
            idx = bases.index(base)
            end = ends[idx]
            interval = intervals[idx] * 60
            return typ, end, interval
    return None, None, None

def play_any_section_by_type(base, end, interval, typ, interruptible, repeat, pausing):
    if typ == "Random":
        play_randomized_section(base, end, interval, random_last_played, random_current_track, interruptible)
    elif typ == "Rotation":
        play_rotating_section(base, end, interval, rotation_last_played, rotation_current_track, interruptible)
    elif typ == "SudoRandom":
        play_sudo_random_section(base, end, interval, sudo_random_last_interval, sudo_random_interval_track, sudo_random_played_in_cycle, interruptible, repeat, pausing)
    else:
        play_direct_track(f"{base:04d}", interruptible, repeat, pausing)

def find_matching_files(base, end):
    files = []
    try:
        for track_num in range(base + 1, end + 1):
            matching = [f for f in os.listdir(SOUND_DIRECTORY)
                        if match_code_file(f, f"{track_num:04d}", SOUND_FILE_EXTENSION)]
            files.extend([os.path.join(SOUND_DIRECTORY, f) for f in matching])
    except Exception:
        log_exception("find_matching_files")
    return files

def get_duration_wav(fname):
    try:
        with contextlib.closing(wave.open(fname, 'r')) as f:
            frames = f.getnframes()
            rate = f.getframerate()
            duration = frames / float(rate)
            return duration
    except Exception:
        log_exception("get_duration_wav")
        return 0

def play_sound(filename, interruptible=False, repeat=False, pausing=False, source="serial/auto"):
    global currently_playing, currently_playing_info, currently_playing_info_timestamp, playing_end_time, playback_interrupt, playback_status, sound_card_missing
    max_interrupts = MAX_COS_INTERRUPTIONS
    cos_interrupts = 0
    playback_interrupt.clear()
    currently_playing = os.path.basename(filename)
    currently_playing_info = f"Playing sound on device: {SOUND_DEVICE} - file: {filename} (Interruptible={interruptible}, Repeat={repeat}, Pausing={pausing})"
    currently_playing_info_timestamp = time.time()
    playing_end_time = currently_playing_info_timestamp + 5
    ret = None
    cos_interrupted = False  # Track if COS actually caused interruption

    try:
        GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)
        if repeat:
            while True:
                interrupted = False
                allow_interrupt = cos_interrupts < max_interrupts
                playback_status = "Playing"
                try:
                    proc = subprocess.Popen(
                        ['aplay', '-D', SOUND_DEVICE, filename],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                except FileNotFoundError:
                    sound_card_missing = True
                    currently_playing_info = "Sound card/device missing or aplay not found!"
                    ret = False
                    break
                except Exception as exc:
                    sound_card_missing = True
                    currently_playing_info = f"Sound card/device error: {exc}"
                    ret = False
                    break
                try:
                    while proc.poll() is None:
                        if allow_interrupt and is_cos_active():
                            playback_status = "Restarting"
                            proc.terminate()
                            time.sleep(0.2)
                            if proc.poll() is None:
                                proc.kill()
                            cos_interrupts += 1
                            interrupted = True
                            cos_interrupted = True
                            while is_cos_active() and not playback_interrupt.is_set():
                                time.sleep(0.05)
                            break
                        if playback_interrupt.is_set():
                            proc.terminate()
                            break
                        time.sleep(0.05)
                finally:
                    if proc.poll() is None:
                        proc.kill()
                    proc.wait()
                if interrupted and cos_interrupts < max_interrupts and not playback_interrupt.is_set():
                    continue
                if cos_interrupts >= max_interrupts and not playback_interrupt.is_set():
                    playback_status = "Playing"
                    try:
                        proc = subprocess.Popen(
                            ['aplay', '-D', SOUND_DEVICE, filename],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL
                        )
                    except FileNotFoundError:
                        sound_card_missing = True
                        currently_playing_info = "Sound card/device missing or aplay not found!"
                        ret = False
                        break
                    except Exception as exc:
                        sound_card_missing = True
                        currently_playing_info = f"Sound card/device error: {exc}"
                        ret = False
                        break
                    try:
                        while proc.poll() is None:
                            if playback_interrupt.is_set():
                                proc.terminate()
                                break
                            time.sleep(0.05)
                    finally:
                        if proc.poll() is None:
                            proc.kill()
                        proc.wait()
                    ret = proc.returncode == 0
                    break
                ret = proc.returncode == 0
                break
        elif pausing:
            total_duration = get_duration_wav(filename)
            played_duration = 0
            while played_duration < total_duration:
                sox_cmd = [
                    'sox', filename, '-t', 'wav', '-', 'trim', f'{played_duration}'
                ]
                try:
                    proc1 = subprocess.Popen(sox_cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
                    proc2 = subprocess.Popen(['aplay', '-D', SOUND_DEVICE], stdin=proc1.stdout, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    proc1.stdout.close()
                except FileNotFoundError:
                    sound_card_missing = True
                    currently_playing_info = "Sound card/device missing or aplay/sox not found!"
                    ret = False
                    break
                except Exception as exc:
                    sound_card_missing = True
                    currently_playing_info = f"Sound card/device error: {exc}"
                    ret = False
                    break
                interrupted = False
                start_time = time.time()
                playback_status = "Playing"
                while proc2.poll() is None:
                    if is_cos_active():
                        if cos_interrupts < max_interrupts:
                            playback_status = "Pausing"
                            proc2.terminate()
                            proc1.terminate()
                            time.sleep(0.1)
                            if proc2.poll() is None:
                                proc2.kill()
                            if proc1.poll() is None:
                                proc1.kill()
                            cos_interrupts += 1
                            interrupted = True
                            cos_interrupted = True
                            played_duration += time.time() - start_time
                            while is_cos_active() and not playback_interrupt.is_set():
                                time.sleep(0.05)
                            break
                        else:
                            proc2.terminate()
                            proc1.terminate()
                            if proc2.poll() is None:
                                proc2.kill()
                            if proc1.poll() is None:
                                proc1.kill()
                            played_duration = total_duration
                            ret = False
                            break
                    if playback_interrupt.is_set():
                        proc2.terminate()
                        proc1.terminate()
                        ret = False
                        break
                    time.sleep(0.05)
                if proc2.poll() is None:
                    proc2.kill()
                if proc1.poll() is None:
                    proc1.kill()
                if not interrupted or cos_interrupts >= max_interrupts or playback_interrupt.is_set():
                    break
            ret = True if not sound_card_missing else False
        else:
            playback_status = "Playing"
            cos_interrupted_local = False
            try:
                proc = subprocess.Popen(
                    ['aplay', '-D', SOUND_DEVICE, filename],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except FileNotFoundError:
                sound_card_missing = True
                currently_playing_info = "Sound card/device missing or aplay not found!"
                ret = False
            except Exception as exc:
                sound_card_missing = True
                currently_playing_info = f"Sound card/device error: {exc}"
                ret = False
            else:
                try:
                    while proc.poll() is None:
                        if interruptible and is_cos_active():
                            proc.terminate()
                            time.sleep(0.2)
                            if proc.poll() is None:
                                proc.kill()
                            cos_interrupted_local = True
                            cos_interrupted = True
                            break
                        if playback_interrupt.is_set():
                            proc.terminate()
                            break
                        time.sleep(0.05)
                finally:
                    if proc.poll() is None:
                        proc.kill()
                    proc.wait()
                ret = proc.returncode == 0
    except Exception:
        log_exception("play_sound")
        ret = False
    finally:
        playback_status = ""
        try:
            GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
        except Exception:
            log_exception("play_sound (GPIO cleanup)")
        currently_playing = ""
        currently_playing_info = ""
        currently_playing_info_timestamp = 0
        playing_end_time = 0

    # --- LOGGING FOR ALL PLAY ATTEMPTS ---
    if filename:
        if ret:
            log_recent(f"Play ({source}): {os.path.basename(filename)} - successful")
        elif interruptible and cos_interrupted:
            log_recent(f"Play ({source}): {os.path.basename(filename)} - interrupted -> playback stopped")
        else:
            log_recent(f"Play ({source}): {os.path.basename(filename)} - failed -> playback error")

def play_randomized_section(base, end, interval, last_played_dict, current_track_dict, interruptible=False):
    try:
        current_time = time.time()
        last_played = last_played_dict.get(base, 0)
        current_track = current_track_dict.get(base, None)
        matching_files = find_matching_files(base, end)
        if not matching_files:
            return
        if current_time - last_played >= interval or current_track not in matching_files:
            new_track = random.choice(matching_files)
            current_track_dict[base] = new_track
            last_played_dict[base] = current_time
        else:
            new_track = current_track
        threading.Thread(target=play_sound, args=(new_track, interruptible), kwargs={'source': "serial/auto"}).start()
    except Exception:
        log_exception("play_randomized_section")

def play_rotating_section(base, end, interval, last_played_dict, current_track_dict, interruptible=False, repeat=False, pausing=False):
    try:
        current_time = time.time()
        last_played = last_played_dict.get(base, 0)
        # Build a list of (track_num, filename) for all present files in the range
        available_tracks = []
        for track_num in range(base + 1, end + 1):
            for f in os.listdir(SOUND_DIRECTORY):
                if match_code_file(f, f"{track_num:04d}", SOUND_FILE_EXTENSION):
                    available_tracks.append((track_num, f))
                    break  # Only take the first matching file for each number

        if not available_tracks:
            return

        # Get just the numbers for rotating
        available_nums = [num for num, _ in available_tracks]

        if base not in current_track_dict or current_track_dict[base] not in available_nums:
            current_track_num = available_nums[0]
        else:
            current_track_num = current_track_dict[base]

        if last_played == 0:
            next_track_idx = available_nums.index(current_track_num)
            last_played_dict[base] = current_time
        elif current_time - last_played >= interval:
            idx = available_nums.index(current_track_num)
            next_track_idx = (idx + 1) % len(available_nums)
            last_played_dict[base] = current_time
        else:
            next_track_idx = available_nums.index(current_track_num)

        next_track_num, next_file = available_tracks[next_track_idx]
        current_track_dict[base] = next_track_num
        next_track = os.path.join(SOUND_DIRECTORY, next_file)
        threading.Thread(
            target=play_sound,
            args=(next_track, interruptible, repeat, pausing),
            kwargs={'source': "serial/auto"}
        ).start()
        rotation_active[base] = False
    except Exception:
        log_exception("play_rotating_section")
        rotation_active[base] = False

def play_sudo_random_section(base, end, interval, last_interval_dict, interval_track_dict, played_in_cycle_dict, interruptible=False, repeat=False, pausing=False):
    global sudo_random_last_file
    current_time = time.time()
    matching_files = find_matching_files(base, end)
    if not matching_files:
        return
    last_interval = last_interval_dict.get(base, 0)
    current_track = interval_track_dict.get(base)
    played_in_cycle = played_in_cycle_dict.get(base, set())
    if current_track is not None and (current_time - last_interval < interval) and current_track in matching_files:
        file_to_play = current_track
    else:
        unused_tracks = [t for t in matching_files if t not in played_in_cycle]
        if not unused_tracks:
            played_in_cycle = set()
            unused_tracks = matching_files[:]
        new_track = random.choice(unused_tracks)
        file_to_play = new_track
        interval_track_dict[base] = file_to_play
        last_interval_dict[base] = current_time
        played_in_cycle.add(file_to_play)
        played_in_cycle_dict[base] = played_in_cycle
    sudo_random_last_file[base] = file_to_play
    threading.Thread(target=play_sound, args=(file_to_play, interruptible, repeat, pausing), kwargs={'source': "serial/auto"}).start()

def play_direct_track(code_str, interruptible=False, repeat=False, pausing=False):
    matches = [f for f in os.listdir(SOUND_DIRECTORY)
           if match_code_file(f, code_str, SOUND_FILE_EXTENSION)]
    if matches:
        filename = os.path.join(SOUND_DIRECTORY, matches[0])
    # ...
        threading.Thread(target=play_sound, args=(filename, interruptible, repeat, pausing), kwargs={'source': "serial/auto"}).start()
    else:
        log_recent(f"Play (serial/auto): {os.path.basename(filename)} - failed -> file not found")

def parse_serial_command(command):
    try:
        # Support PxxxxiYYYY for COS-i
        m = re.match(r'^P(\d{4})i(\d{4})$', command)
        if m:
            return (m.group(1), 'i', m.group(2))
        # Support alternate series
        bases, suffix, is_alt = parse_alternate_series(command)
        if is_alt:
            return (None, None, None)
        # Support Pxxxx, PxxxxI, etc.
        m = re.match(r'^P(\d{4})([IRP]?)$', command)
        if not m:
            m2 = re.match(r'^P(\d{4})([IRP])', command)
            if m2:
                return (m2.group(1), m2.group(2), None)
            return (None, None, None)
        return (m.group(1), m.group(2), None)
    except Exception:
        log_exception("parse_serial_command")
        return (None, None, None)

def auto_alternate_series(command, interval_per_base=60):
    # interval_per_base should match your config for [Rotation] time in seconds
    # If you want to read the real interval for each base from your config, you can do so.
    bases, _, is_alt = parse_alternate_series(command)
    if not is_alt or not bases:
        print("Not a valid alternate series command.")
        return

    key = tuple(sorted(bases))
    pointer = 0

    while True:
        current_base = bases[pointer]
        process_command(command)
        print(f"Played base {current_base}, waiting {interval_per_base} seconds before next base...")
        time.sleep(interval_per_base)
        pointer = (pointer + 1) % len(bases)

def get_next_base_file(base_code):
    typ, end, interval = get_base_type_and_info(base_code)
    if typ == "Rotation":
        available_tracks = []
        for track_num in range(base_code + 1, end + 1):
            for f in os.listdir(SOUND_DIRECTORY):
                if match_code_file(f, f"{track_num:04d}", SOUND_FILE_EXTENSION):
                    available_tracks.append((track_num, f))
                    break
        if not available_tracks:
            return None
        available_nums = [num for num, _ in available_tracks]
        current_num = rotation_current_track.get(base_code, available_nums[0])
        if current_num not in available_nums:
            current_num = available_nums[0]
        idx = available_nums.index(current_num)
        now = time.time()
        last_played = rotation_last_played.get(base_code, 0)
        if last_played == 0:
            next_idx = idx
            rotation_last_played[base_code] = now
        elif now - last_played >= interval:
            next_idx = (idx + 1) % len(available_nums)
            rotation_last_played[base_code] = now
        else:
            next_idx = idx
        rotation_current_track[base_code] = available_nums[next_idx]
        return os.path.join(SOUND_DIRECTORY, available_tracks[next_idx][1])
    elif typ == "Random":
        matching_files = find_matching_files(base_code, end)
        if not matching_files:
            return None
        last_played = random_last_played.get(base_code, 0)
        current_track = random_current_track.get(base_code, None)
        now = time.time()
        if now - last_played >= interval or current_track not in matching_files:
            chosen = random.choice(matching_files)
            random_current_track[base_code] = chosen
            random_last_played[base_code] = now
            return chosen
        else:
            return current_track
    elif typ == "SudoRandom":
        matching_files = find_matching_files(base_code, end)
        if not matching_files:
            return None
        played_in_cycle = sudo_random_played_in_cycle.get(base_code, set())
        if not isinstance(played_in_cycle, set):
            played_in_cycle = set(played_in_cycle)
        unused_tracks = [t for t in matching_files if t not in played_in_cycle]
        if not unused_tracks:
            played_in_cycle = set()
            unused_tracks = matching_files[:]
        chosen = random.choice(unused_tracks)
        sudo_random_interval_track[base_code] = chosen
        sudo_random_last_interval[base_code] = time.time()
        played_in_cycle.add(chosen)
        sudo_random_played_in_cycle[base_code] = played_in_cycle
        return chosen
    else:
        return os.path.join(SOUND_DIRECTORY, f"{base_code:04d}{SOUND_FILE_EXTENSION}")

def process_command(command):
    debug_log("process_command reached")
    debug_log(f"RAW process_command input: {repr(command)}")
    try:
        playback_interrupt.set()
        time.sleep(0.1)

        bases, alt_suffix, is_alt = parse_alternate_series(command.strip())
        debug_log(f"parse_alternate_series: bases={bases}, alt_suffix={alt_suffix}, is_alt={is_alt}")
        if is_alt and bases:
            cosi_interrupt_code = None
            if alt_suffix and alt_suffix.lower().startswith('i') and len(alt_suffix) > 1 and alt_suffix[1:].isdigit():
                cosi_interrupt_code = alt_suffix[1:]
            debug_log(f"cosi_interrupt_code={cosi_interrupt_code}")

            interruptible = (alt_suffix == "I")
            repeat = (alt_suffix == "R")
            pausing = (alt_suffix == "P")
            key = tuple(sorted(bases))

            if key not in alternate_series_pointers:
                alternate_series_pointers[key] = 0
            pointer = alternate_series_pointers[key]
            debug_log(f"Pointer before loop: {pointer}")

            start_pointer = pointer
            played = False

            for step in range(len(bases)):
                base = bases[pointer]
                debug_log(f"Trying base {base} at pointer {pointer}")
                base_filename = get_next_base_file(base)
                debug_log(f"base_filename={base_filename}")

                if base_filename:
                    if cosi_interrupt_code:
                        filename2 = os.path.join(SOUND_DIRECTORY, f"{cosi_interrupt_code}{SOUND_FILE_EXTENSION}")
                        debug_log(f"Launching COS-i sequence: {base_filename} (interrupt: {filename2})")
                        def cos_i_sequence():
                            print(f"[Thread] Would play: {base_filename}")
                            os.system(f"aplay -D {SOUND_DEVICE} '{base_filename}'")

                            # (rest as before...)
                        threading.Thread(target=cos_i_sequence, daemon=True).start()
                    else:
                        debug_log(f"Launching play_sound for {base_filename}")
                        threading.Thread(
                            target=play_sound,
                            args=(base_filename, interruptible, repeat, pausing),
                            kwargs={'source': "serial/auto"}
                        ).start()
                    played = True
                    break
                else:
                    debug_log(f"No file for base {base}, advancing pointer.")

                pointer = (pointer + 1) % len(bases)
                if pointer == start_pointer:
                    debug_log("Looped over all bases, nothing to play.")
                    break

            alternate_series_pointers[key] = (pointer + 1) % len(bases) if played else pointer
            debug_log(f"Pointer after loop: {alternate_series_pointers[key]}")
            return

        # --- EVERYTHING ELSE (unchanged) ---
        code_str, suffix, alt_code = parse_serial_command(command.strip())
        if code_str is None:
            return

        debug_log(f"rotation_bases: {rotation_bases}, types: {[type(x) for x in rotation_bases]}")
        debug_log(f"code: {code_str}, type: {type(code_str)}")
        code = int(code_str)
        debug_log(f"code (int): {code}, type: {type(code)}")

        if suffix == 'i' and alt_code is not None:
            log_recent(f"[COS-i] Handling P{code_str}i{alt_code}")
            base_code = int(code_str)
            base_filename = get_next_base_file(base_code)
            if not base_filename:
                log_recent(f"[COS-i] No available file for base {base_code}")
                return
            filename2 = os.path.join(SOUND_DIRECTORY, f"{alt_code}{SOUND_FILE_EXTENSION}")

            def cos_i_sequence():
                global currently_playing, currently_playing_info, currently_playing_info_timestamp, playing_end_time, playback_status
                try:
                    currently_playing = os.path.basename(base_filename)
                    currently_playing_info = f"[COS-i] Step 1: Playing {base_filename} (COS interruptible)"
                    currently_playing_info_timestamp = time.time()
                    playing_end_time = currently_playing_info_timestamp + 5
                    GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)

                    proc = subprocess.Popen(
                        ['aplay', '-D', SOUND_DEVICE, base_filename],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                    cos_triggered = False
                    while proc.poll() is None:
                        if is_cos_active():
                            log_recent("[COS-i] COS went ACTIVE, stopping 1st file.")
                            proc.terminate()
                            cos_triggered = True
                            break
                        time.sleep(0.05)
                    if proc.poll() is None:
                        proc.kill()
                    proc.wait()
                    GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
                    if not cos_triggered:
                        return
                    log_recent("[COS-i] Interrupt triggered, playing 2nd file immediately")
                    log_recent(f"[COS-i] Step 2: Playing {filename2} (UNinterruptible)")
                    currently_playing = os.path.basename(filename2)
                    currently_playing_info = f"[COS-i] Step 2: Playing {filename2} (UNinterruptible)"
                    currently_playing_info_timestamp = time.time()
                    playing_end_time = currently_playing_info_timestamp + 5
                    GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)
                    proc2 = subprocess.Popen(['aplay', '-D', SOUND_DEVICE, filename2])
                    proc2.wait()
                    GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
                    log_recent("[COS-i] Sequence complete.")
                except Exception:
                    log_exception("cos_i_sequence")
                finally:
                    GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
                    currently_playing = ""
                    currently_playing_info = ""
                    currently_playing_info_timestamp = 0
                    playing_end_time = 0

            threading.Thread(target=cos_i_sequence, daemon=True).start()
            return

        # normal sections (unchanged)
        interruptible = (suffix == "I")
        repeat = (suffix == "R")
        pausing = (suffix == "P")
        code = int(code_str)
        for b, e, t in zip(random_bases, random_ends, random_intervals):
            if code == b:
                play_randomized_section(b, e, t * 60, random_last_played, random_current_track, interruptible)
                return
            elif b < code <= e:
                play_direct_track(code_str, interruptible, repeat, pausing)
                return
        for b, e, t in zip(rotation_bases, rotation_ends, rotation_times):
            if code == b:
                if not rotation_active.get(b, False):
                    rotation_active[b] = True
                    play_rotating_section(b, e, t * 60, rotation_last_played, rotation_current_track, interruptible, repeat, pausing)
                else:
                    debug_log(f"Rotation for base {b} is already active, ignoring repeat trigger.")
                return
            elif b < code <= e:
                play_direct_track(code_str, interruptible, repeat, pausing)
                return
        for b, e, t in zip(sudo_bases, sudo_ends, sudo_intervals):
            if code == b:
                play_sudo_random_section(
                    b, e, t * 60,
                    sudo_random_last_interval,
                    sudo_random_interval_track,
                    sudo_random_played_in_cycle,
                    interruptible, repeat, pausing
                )
                return
            elif b < code <= e:
                play_direct_track(code_str, interruptible, repeat, pausing)
                return
        if DIRECT_ENABLED:
            play_direct_track(code_str, interruptible, repeat, pausing)
    except Exception:
        log_exception("process_command")

def write_state():
    now = time.time()
    # Build your *lines* (random_bases_lines, etc.) and all your additional state here, as in your first function
    random_bases_lines = []
    for b, e, t in zip(random_bases, random_ends, random_intervals):
        last = random_last_played.get(b, 0)
        current = random_current_track.get(b, 'N/A')
        remaining = max(0, t*60 - (now - last))
        track_name = os.path.basename(current) if current != 'N/A' and current else 'N/A'
        random_bases_lines.append(f"Base {b} | End {e} Interval {t}: Track={track_name} Remaining={remaining:.1f}s")
    # ...repeat for rotation_bases_lines, sudorandom_bases_lines, alt_bases_lines...

    state = {
        "currently_playing": currently_playing,
        "currently_playing_info": currently_playing_info,
        "currently_playing_info_timestamp": currently_playing_info_timestamp,
        "playing_end_time": playing_end_time,
        "playback_status": playback_status,
        "serial_port_missing": serial_port_missing,
        "sound_card_missing": sound_card_missing,
        "serial_history": serial_history[-10:],
        "cos_active": is_cos_active(),
        "remote_device_active": is_remote_device_active(),
        "uptime": get_drx_uptime(),
        # Include all custom lines and additional state
        "random_last_played": random_last_played,
        "random_current_track": {k: os.path.basename(v) if v else v for k, v in random_current_track.items()},
        "rotation_last_played": rotation_last_played,
        "rotation_current_track": rotation_current_track,
        "sudo_random_last_interval": sudo_random_last_interval,
        "sudo_random_interval_track": {k: os.path.basename(v) if v else v for k, v in sudo_random_interval_track.items()},
        "sudo_random_played_in_cycle": {k: [os.path.basename(x) for x in v] for k, v in sudo_random_played_in_cycle.items()},
        "random_bases_lines": random_bases_lines,
        # ... and so on for other *_lines ...
        "drx_start_time": DRX_START_TIME,
        "updated_at": now,
    }
    try:
        debug_log(f"write_state() called with: {state}")
        with open(STATE_FILE, 'w') as f:
            json.dump(state, f)
    except Exception as e:
        debug_log(f"write_state() exception: {e}")

def reload_config():
    global config, SOUND_DIRECTORY, SOUND_FILE_EXTENSION, SOUND_DEVICE
    global COS_PIN, COS_ACTIVE_LEVEL, REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL, COS_DEBOUNCE_TIME, MAX_COS_INTERRUPTIONS
    global SERIAL_PORT, SERIAL_BAUDRATE, SERIAL_TIMEOUT
    global RANDOM_BASE, RANDOM_END, RANDOM_INTERVAL, ROTATION_BASE, ROTATION_END, ROTATION_TIME
    global SUDORANDOM_BASE, SUDORANDOM_END, SUDORANDOM_INTERVAL, DIRECT_ENABLED, DIRECT_PREFIX
    global random_bases, random_ends, random_intervals, rotation_bases, rotation_ends, rotation_times
    global sudo_bases, sudo_ends, sudo_intervals

    config.read(config_file_path)
    SOUND_DIRECTORY = get_config_value("Sound", "directory", DEFAULTS["Sound"]["directory"])
    SOUND_FILE_EXTENSION = get_config_value("Sound", "extension", DEFAULTS["Sound"]["extension"])
    SOUND_DEVICE = get_config_value("Sound", "device", DEFAULTS["Sound"]["device"])

    COS_PIN = get_config_value("GPIO", "cos_pin", DEFAULTS["GPIO"]["cos_pin"], int)
    COS_ACTIVE_LEVEL = get_config_value("GPIO", "cos_activate_level", DEFAULTS["GPIO"]["cos_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
    REMOTE_BUSY_PIN = get_config_value("GPIO", "remote_busy_pin", DEFAULTS["GPIO"]["remote_busy_pin"], int)
    REMOTE_BUSY_ACTIVE_LEVEL = get_config_value("GPIO", "remote_busy_activate_level", DEFAULTS["GPIO"]["remote_busy_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
    COS_DEBOUNCE_TIME = get_config_value("GPIO", "cos_debounce_time", DEFAULTS["GPIO"]["cos_debounce_time"], float)
    MAX_COS_INTERRUPTIONS = get_config_value("GPIO", "max_cos_interruptions", DEFAULTS["GPIO"]["max_cos_interruptions"], int)

    SERIAL_PORT = get_config_value("Serial", "port", DEFAULTS["Serial"]["port"])
    SERIAL_BAUDRATE = get_config_value("Serial", "baudrate", DEFAULTS["Serial"]["baudrate"], int)
    SERIAL_TIMEOUT = get_config_value("Serial", "timeout", DEFAULTS["Serial"]["timeout"], float)

    RANDOM_BASE = get_config_value("Random", "base", DEFAULTS["Random"]["base"])
    RANDOM_END = get_config_value("Random", "end", DEFAULTS["Random"]["end"])
    RANDOM_INTERVAL = get_config_value("Random", "interval", DEFAULTS["Random"]["interval"])
    ROTATION_BASE = get_config_value("Rotation", "base", DEFAULTS["Rotation"]["base"])
    ROTATION_END = get_config_value("Rotation", "end", DEFAULTS["Rotation"]["end"])
    ROTATION_TIME = get_config_value("Rotation", "time", DEFAULTS["Rotation"]["time"])
    SUDORANDOM_BASE = get_config_value("SudoRandom", "base", DEFAULTS["SudoRandom"]["base"])
    SUDORANDOM_END = get_config_value("SudoRandom", "end", DEFAULTS["SudoRandom"]["end"])
    SUDORANDOM_INTERVAL = get_config_value("SudoRandom", "interval", DEFAULTS["SudoRandom"]["interval"])
    DIRECT_ENABLED = get_config_value("Direct", "enabled", DEFAULTS["Direct"]["enabled"], lambda x: str(x).lower() in ("1", "true", "yes"))
    DIRECT_PREFIX = get_config_value("Direct", "prefix", DEFAULTS["Direct"]["prefix"])

    random_bases[:] = parse_int_list(RANDOM_BASE, fallback=3000, label="Random base", section="Random")
    random_ends[:] = parse_int_list(RANDOM_END, fallback=3099, label="Random end", section="Random")
    random_intervals[:] = parse_float_list(RANDOM_INTERVAL, fallback=10, label="Random interval", section="Random")
    rotation_bases[:] = parse_int_list(ROTATION_BASE, fallback=4000, label="Rotation base", section="Rotation")
    rotation_ends[:] = parse_int_list(ROTATION_END, fallback=4099, label="Rotation end", section="Rotation")
    rotation_times[:] = parse_float_list(ROTATION_TIME, fallback=10, label="Rotation time", section="Rotation")
    sudo_bases[:] = parse_int_list(SUDORANDOM_BASE, fallback=5000, label="SudoRandom base", section="SudoRandom")
    sudo_ends[:] = parse_int_list(SUDORANDOM_END, fallback=5099, label="SudoRandom end", section="SudoRandom")
    sudo_intervals[:] = parse_float_list(SUDORANDOM_INTERVAL, fallback=10, label="SudoRandom interval", section="SudoRandom")

    validate_config_pairs()

def play_sound_sync(filename, interruptible=False, repeat=False, pausing=False):
    global currently_playing, currently_playing_info, currently_playing_info_timestamp, playing_end_time, playback_interrupt, playback_status, sound_card_missing
    playback_interrupt.clear()
    currently_playing = os.path.basename(filename)
    currently_playing_info = f"Playing (sync): {filename}"
    currently_playing_info_timestamp = time.time()
    playing_end_time = currently_playing_info_timestamp + 5
    write_state()  # <-- Instantly write state after starting playback!
    try:
        GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)
        proc = subprocess.Popen(
            ['aplay', '-D', SOUND_DEVICE, filename],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        # --- Periodically update state while playback is running ---
        last_update = time.time()
        while proc.poll() is None:
            time.sleep(0.05)
            now = time.time()
            if now - last_update >= 1.0:   # Update every second
                write_state()
                last_update = now
        ret = proc.returncode == 0
    except Exception:
        log_exception("play_sound_sync")
        ret = False
    finally:
        playback_status = ""
        try:
            GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
        except Exception:
            log_exception("play_sound_sync (GPIO cleanup)")
        currently_playing = ""
        currently_playing_info = ""
        currently_playing_info_timestamp = 0
        playing_end_time = 0
        write_state()  # <-- Instantly write state after stopping playback!
    if filename:
        if ret:
            log_recent(f"Play (web): {os.path.basename(filename)} - successful")
        else:
            log_recent(f"Play (web): {os.path.basename(filename)} - failed -> playback error")
    return ret

def maybe_run_webcmd():
    if os.path.exists(WEBCMD_FILE):
        try:
            with open(WEBCMD_FILE, 'r') as f:
                cmd = json.load(f)
            if cmd.get("type") == "play":
                input_cmd = cmd.get("input", "")
                # WAV file play request
                if input_cmd.lower().endswith('.wav'):
                    path = os.path.join(SOUND_DIRECTORY, input_cmd)
                    if os.path.exists(path):
                        ok = play_sound_sync(path)
                        if ok:
                            log_recent(f"Play requested: {input_cmd} (dropdown, exact file) - successful")
                        else:
                            log_recent(f"Play requested: {input_cmd} (dropdown, exact file) - failed -> playback error")
                    else:
                        log_recent(f"Play requested: {input_cmd} (dropdown, exact file) - failed -> file not found")
                # Serial command from web input box
                else:
                    try:
                        serial_out = process_command(input_cmd)
                        log_recent(f"Play requested: {input_cmd} (input) - processed by process_command")
                        # --- Update global and state serial_history ---
                        global serial_history
                        # Insert serial command and (if present) output
                        serial_history.insert(0, f"> {input_cmd}")
                        if serial_out:
                            serial_history.insert(0, f"{serial_out}")
                        serial_history = serial_history[:10]
                        # Update state file
                        state = read_state()
                        state['serial_history'] = serial_history
                        with open(STATE_FILE, 'w') as sf:
                            json.dump(state, sf)
                    except Exception as e:
                        log_recent(f"Play requested: {input_cmd} (input) - failed -> {e}")
            elif cmd.get("type") == "stop":
                playback_interrupt.set()
                log_recent("Playback stopped from web")
            elif cmd.get("type") == "reload_config":
                reload_config()
                log_recent("Configuration reload requested from web")
            elif cmd.get("type") == "restart":
                log_recent("DRX script restart requested from web")
                os.remove(WEBCMD_FILE)
                os.execv(sys.executable, [sys.executable] + sys.argv)
                return
            elif cmd.get("type") == "reboot":
                log_recent("System reboot requested from web")
            os.remove(WEBCMD_FILE)
        except Exception:
            log_exception("maybe_run_webcmd")

def serial_read_loop():
    debug_log("serial_read_loop running")
    global serial_buffer, serial_port_missing
    while True:
        try:
            if serial_port and serial_port.in_waiting:
                data = serial_port.read(serial_port.in_waiting)
                try:
                    decoded = data.decode('ascii')
                    cleaned = ''.join(c for c in decoded if c in string.printable and c not in '\x1b')
                    serial_buffer += cleaned
                    debug_log(f"serial_read_loop read data: {repr(cleaned)}")
                    for line in cleaned.splitlines():
                        if line.strip():
                            serial_history.insert(0, line.strip())
                            if len(serial_history) > 10:
                                serial_history.pop()
                except UnicodeDecodeError:
                    log_error("UnicodeDecodeError in serial_read_loop")
        except Exception:
            serial_port_missing = True
            log_exception("serial_read_loop")
        time.sleep(0.05)

def process_serial_commands():
    debug_log("process_serial_commands running")
    global serial_buffer
    pattern = r'P\d{4}i\d{4}|P\d{4}[IRP]?'
    while True:
        try:
            if serial_buffer.strip():
                debug_log(f"SERIAL BUFFER: {repr(serial_buffer)}")
            match = re.search(pattern, serial_buffer)
            if match:
                command = match.group(0)
                debug_log(f"COMMAND MATCH FOUND: {repr(command)}")
                debug_log(f"process_serial_commands calling process_command with: {repr(command)}")
                process_command(command)
                serial_buffer = serial_buffer.replace(command, '', 1)
            time.sleep(0.1)
        except Exception:
            log_exception("process_serial_commands")

def status_screen(stdscr):
    global serial_buffer, currently_playing, currently_playing_info, currently_playing_info_timestamp, playing_end_time, playback_status, serial_port_missing, sound_card_missing
    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_BLACK)
    curses.init_pair(6, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(7, curses.COLOR_MAGENTA, curses.COLOR_BLACK)  # New color for Remote Device Active, if desired
    curses.curs_set(0)
    stdscr.nodelay(True)
    flash_state = itertools.cycle([True, False])
    while True:
        try:
            stdscr.erase()
            y = 0
            warning_msgs = []
            if serial_port_missing:
                warning_msgs.append("SERIAL PORT NOT FOUND")
            if sound_card_missing:
                warning_msgs.append("SOUND CARD/DEVICE NOT FOUND")
            if config_warnings and next(flash_state):
                warning_msgs.extend(config_warnings)
            if warning_msgs:
                for line in warning_msgs:
                    stdscr.addstr(y, 0, line, curses.color_pair(6) | curses.A_BOLD)
                    y += 1
            stdscr.addstr(y, 0, f"{SCRIPT_NAME} v{VERSION} - Status Screen", curses.color_pair(1))
            y += 1
            y += 1
            stdscr.addstr(y, 0, "Rotation Bases State:", curses.color_pair(2))
            y += 1
            for b, e, t in zip(rotation_bases, rotation_ends, rotation_times):
                last = rotation_last_played.get(b, 0)
                current_num = rotation_current_track.get(b, b+1)
                remaining = max(0, t*60 - (time.time() - last))
                stdscr.addstr(y, 0, f"Base {b} | End {e} Interval {t}: Track={current_num} Remaining={remaining:.1f}s", curses.color_pair(3))
                y += 1
            y += 1
            stdscr.addstr(y, 0, "Random Bases State:", curses.color_pair(2))
            y += 1
            for b, e, t in zip(random_bases, random_ends, random_intervals):
                last = random_last_played.get(b, 0)
                current = random_current_track.get(b, 'N/A')
                remaining = max(0, t*60 - (time.time() - last))
                track_name = os.path.basename(current) if current != 'N/A' and current else 'N/A'
                stdscr.addstr(y, 0, f"Base {b} | End {e} Interval {t}: Track={track_name} Remaining={remaining:.1f}s", curses.color_pair(3))
                y += 1
            y += 1
            stdscr.addstr(y, 0, "SudoRandom Bases State:", curses.color_pair(2))
            y += 1
            for b, e, t in zip(sudo_bases, sudo_ends, sudo_intervals):
                last = sudo_random_last_interval.get(b, 0)
                current = sudo_random_interval_track.get(b, 'N/A')
                played = sudo_random_played_in_cycle.get(b, set())
                remaining = max(0, t*60 - (time.time() - last))
                track_name = os.path.basename(current) if current != 'N/A' and current else 'N/A'
                stdscr.addstr(y, 0, f"Base {b} | End {e} Interval {t}: Track={track_name} Remaining={remaining:.1f}s PlayedInCycle={len(played)}", curses.color_pair(3))
                y += 1
            y += 1
            stdscr.move(y, 0)
            stdscr.clrtoeol()
            serial_display = ' | '.join(
                ''.join(c for c in s if c in string.printable and c not in '\x1b') for s in serial_history[:5]
            ) if serial_history else 'None'
            stdscr.addstr(y, 0, f"Serial Buffer: {serial_display}", curses.color_pair(5))
            y += 1
            y += 1
            stdscr.move(y, 0)
            stdscr.clrtoeol()
            if playback_status == "Pausing":
                label = "Currently Pausing:"
            elif playback_status == "Restarting":
                label = "Currently Pending Restart:"
            else:
                label = "Currently Playing:"
            info_clean = ''.join(c for c in currently_playing if c in string.printable and c not in '\x1b')
            stdscr.addstr(y, 0, f"{label} {info_clean if info_clean else 'None'}", curses.color_pair(4))
            y += 1
            if currently_playing_info:
                if time.time() - currently_playing_info_timestamp < 5:
                    info2 = ''.join(c for c in currently_playing_info if c in string.printable and c not in '\x1b')
                    stdscr.addstr(y, 0, info2, curses.color_pair(4))
                else:
                    currently_playing_info = ""
                    currently_playing_info_timestamp = 0
            y += 1
            y += 1
            # COS and Remote Device Active indicators, side by side
            cos_state = is_cos_active()
            cos_color = curses.color_pair(2) if cos_state else curses.color_pair(5)
            remote_state = is_remote_device_active()  # <-- you must define this function/variable in your backend
            remote_color = curses.color_pair(2) if remote_state else curses.color_pair(5)
            status_str = f"COS Active: {'YES' if cos_state else 'NO'}   Remote Device: {'YES' if remote_state else 'NO'}"
            # To highlight each part differently, split the addstr calls:
            stdscr.addstr(y, 0, "COS Active: ", curses.color_pair(5))
            stdscr.addstr(f"{'YES' if cos_state else 'NO'}   ", cos_color | curses.A_BOLD)
            stdscr.addstr("Remote Device: ", curses.color_pair(5))
            stdscr.addstr(f"{'YES' if remote_state else 'NO'}", remote_color | curses.A_BOLD)
            y += 1
            y += 1
            stdscr.move(y, 0)
            stdscr.clrtoeol()
            max_y, _ = stdscr.getmaxyx()
            stdscr.move(max_y - 1, 0)
            stdscr.clrtoeol()
            stdscr.addstr(max_y - 1, 0, "Press q to quit", curses.color_pair(1))
            stdscr.refresh()
            try:
                if stdscr.getkey() == 'q':
                    break
            except curses.error:
                pass
            time.sleep(0.5)
        except Exception:
            log_exception("status_screen")

def bg_write_state_and_webcmd_loop():
    while True:
        maybe_run_webcmd()
        write_state()
        time.sleep(0.25)

import json

def bg_cos_state_update_loop():
    global cos_active
    last_cos = None
    while True:
        try:
            cos_now = is_cos_active()
            if cos_now != last_cos:
                cos_active = cos_now
                last_cos = cos_now
        except Exception:
            pass
        time.sleep(0.05)

def fallback_command_prompt():
    print(f"{SCRIPT_NAME} v{VERSION} - Fallback Command Prompt")
    print("Enter DRX commands. Type 'exit' or 'quit' to exit.")
    while True:
        try:
            cmd = input("> ")
            if cmd.strip().lower() in ('exit', 'quit'):
                print("Exiting DRX.")
                sys.exit(0)
            process_command(cmd)
        except KeyboardInterrupt:
            print("\nExiting DRX by Ctrl+C.")
            sys.exit(0)
        except Exception as e:
            print(f"Error: {e}")

def get_drx_uptime():
    now = time.time()
    uptime_seconds = int(now - DRX_START_TIME)
    days, remainder = divmod(uptime_seconds, 86400)
    hours, remainder = divmod(remainder, 3600)
    minutes, seconds = divmod(remainder, 60)
    if days > 0:
        return f"{days}d {hours}h {minutes}m {seconds}s"
    elif hours > 0:
        return f"{hours}h {minutes}m {seconds}s"
    elif minutes > 0:
        return f"{minutes}m {seconds}s"
    else:
        return f"{seconds}s"

def main():
    try:
        threading.Thread(target=serial_read_loop, daemon=True).start()
        threading.Thread(target=process_serial_commands, daemon=True).start()
        threading.Thread(target=bg_write_state_and_webcmd_loop, daemon=True).start()
        threading.Thread(target=bg_cos_state_update_loop, daemon=True).start()
        try:
            curses.wrapper(status_screen)
        except Exception as e:
            print("Curses UI failed to start. Falling back to command prompt mode.")
            log_exception("main (curses fallback)")
            fallback_command_prompt()
            while True:
                time.sleep(1)
    except KeyboardInterrupt:
        pass
    except Exception:
        log_exception("main")
    finally:
        try:
            GPIO.cleanup()
        except Exception:
            log_exception("main (GPIO cleanup)")

if __name__ == "__main__":
    main()
import datetime
import traceback
import wave
import contextlib
import shutil
import itertools
import json
import string
import os
import time
import datetime

# Get the directory where the script is located
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DEBUG_LOG_PATH = os.path.join(SCRIPT_DIR, "debug.log")

def debug_log(msg):
    if not ENABLE_DEBUG_LOGGING:
        return
    with open(DEBUG_LOG_PATH, 'a') as f:
        f.write(msg + '\n')

SCRIPT_NAME = "DRX"
VERSION = "2.02"

STATE_FILE = '/tmp/drx_state.json'
WEBCMD_FILE = '/tmp/drx_webcmd.json'
LOG_WEB_FILE = '/tmp/drx_webconsole.log'

serial_buffer = ""
serial_history = []
currently_playing = ""
currently_playing_info = ""
currently_playing_info_timestamp = 0
playing_end_time = 0
playback_status = ""
rotation_active = {}

serial_port_missing = False
sound_card_missing = False

cos_active = False
DRX_START_TIME = time.time()
script_dir = os.path.dirname(os.path.realpath(__file__))
config_file_path = os.path.join(script_dir, 'config.ini')
log_file_path = os.path.join(script_dir, 'drx_error.log')
alternate_series_pointers = {}         # key: tuple(bases), value: current pointer/index (which base to play next)
alternate_series_track_pointers = {}   # key: tuple(bases), value: dict of base -> current track index (starts at 1)
alternate_series_last_played = {}      # key: tuple(bases), value: dict of base -> last_played_time

# --- Config Loading & Validation ---
DEFAULTS = {
    "Sound": {
        "directory": "/tmp/sounds",
        "extension": ".wav",
        "device": "default"
    },
    "GPIO": {
        "cos_pin": 23,
        "cos_activate_level": True,
        "remote_busy_pin": 25,
        "remote_busy_activate_level": True,
        "cos_debounce_time": 0.5,
        "max_cos_interruptions": 3
    },
    "Serial": {
        "port": "/dev/ttyUSB0",
        "baudrate": 9600,
        "timeout": 0.5
    },
    "Random": {
        "base": "3000",
        "end": "3099",
        "interval": "10"
    },
    "Rotation": {
        "base": "4000",
        "end": "4099",
        "time": "10"
    },
    "SudoRandom": {
        "base": "5000",
        "end": "5099",
        "interval": "10"
    },
    "Direct": {
        "enabled": "true",
        "prefix": "P"
    }
}
config_warnings = []

def match_code_file(f, code_str, ext):
    # Only match 5300.wav or 5300-xxxx.wav (case-insensitive extension), never 5300.anything.wav
    ext = ext.lower()
    f_lower = f.lower()
    return (
        f_lower == f"{code_str}{ext}" or
        (f_lower.startswith(f"{code_str}-") and f_lower.endswith(ext))
    )

def get_config_value(section, key, fallback=None, cast_func=None, warn=None):
    global config_warnings
    if not config.has_section(section):
        config_warnings.append(f"Section [{section}] missing; using defaults.")
        val = DEFAULTS[section][key] if section in DEFAULTS and key in DEFAULTS[section] else fallback
        return cast_func(val) if cast_func else val
    if not config.has_option(section, key):
        config_warnings.append(f"Missing {key} in [{section}]; using default '{DEFAULTS.get(section, {}).get(key, fallback)}'.")
        val = DEFAULTS[section][key] if section in DEFAULTS and key in DEFAULTS[section] else fallback
        return cast_func(val) if cast_func else val
    raw = config[section][key]
    try:
        return cast_func(raw) if cast_func else raw
    except Exception as e:
        config_warnings.append(f"Invalid value for {key} in [{section}]: '{raw}' ({e}); using default '{DEFAULTS.get(section, {}).get(key, fallback)}'.")
        val = DEFAULTS[section][key] if section in DEFAULTS and key in DEFAULTS[section] else fallback
        return cast_func(val) if cast_func else val

def read_state():
    try:
        with open(STATE_FILE, 'r') as f:
            return json.load(f)
    except Exception:
        return {}

def parse_int_list(s, fallback=10, label="", section=""):
    vals = []
    for i, v in enumerate(s.split(',')):
        try:
            if float(v) != int(float(v)):
                config_warnings.append(f"{label} in [{section}]: '{v}' not integer, using {fallback}.")
                vals.append(int(fallback))
            else:
                vals.append(int(float(v)))
        except Exception:
            config_warnings.append(f"{label} in [{section}]: '{v}' invalid, using {fallback}.")
            vals.append(int(fallback))
    return vals

def parse_float_list(s, fallback=10, label="", section=""):
    vals = []
    for i, v in enumerate(s.split(',')):
        try:
            f = float(v)
            if f < 1:
                config_warnings.append(f"{label} in [{section}]: '{v}' < 1, using {fallback}.")
                f = float(fallback)
            elif f != int(f):
                config_warnings.append(f"{label} in [{section}]: '{v}' not integer, using {fallback}.")
                f = float(fallback)
            vals.append(int(f))
        except Exception:
            config_warnings.append(f"{label} in [{section}]: '{v}' invalid, using {fallback}.")
            vals.append(int(fallback))
    return vals

config = configparser.ConfigParser()
config_ini_missing = False
try:
    found_files = config.read(config_file_path)
    if not found_files:
        config_ini_missing = True
        config_warnings.insert(0, f"config.ini missing at {config_file_path}; using all default values.")
except Exception as e:
    config_ini_missing = True
    config_warnings.insert(0, f"Failed to read config.ini: {e}; using all default values.")

ENABLE_DEBUG_LOGGING = get_config_value("Debug", "enable_debug_logging", "false", lambda x: str(x).lower() in ("1", "true", "yes"))

SOUND_DIRECTORY = get_config_value("Sound", "directory", DEFAULTS["Sound"]["directory"])
SOUND_FILE_EXTENSION = get_config_value("Sound", "extension", DEFAULTS["Sound"]["extension"])
SOUND_DEVICE = get_config_value("Sound", "device", DEFAULTS["Sound"]["device"])

COS_PIN = get_config_value("GPIO", "cos_pin", DEFAULTS["GPIO"]["cos_pin"], int)
COS_ACTIVE_LEVEL = get_config_value("GPIO", "cos_activate_level", DEFAULTS["GPIO"]["cos_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
REMOTE_BUSY_PIN = get_config_value("GPIO", "remote_busy_pin", DEFAULTS["GPIO"]["remote_busy_pin"], int)
REMOTE_BUSY_ACTIVE_LEVEL = get_config_value("GPIO", "remote_busy_activate_level", DEFAULTS["GPIO"]["remote_busy_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
COS_DEBOUNCE_TIME = get_config_value("GPIO", "cos_debounce_time", DEFAULTS["GPIO"]["cos_debounce_time"], float)
MAX_COS_INTERRUPTIONS = get_config_value("GPIO", "max_cos_interruptions", DEFAULTS["GPIO"]["max_cos_interruptions"], int)

SERIAL_PORT = get_config_value("Serial", "port", DEFAULTS["Serial"]["port"])
SERIAL_BAUDRATE = get_config_value("Serial", "baudrate", DEFAULTS["Serial"]["baudrate"], int)
SERIAL_TIMEOUT = get_config_value("Serial", "timeout", DEFAULTS["Serial"]["timeout"], float)

RANDOM_BASE = get_config_value("Random", "base", DEFAULTS["Random"]["base"])
RANDOM_END = get_config_value("Random", "end", DEFAULTS["Random"]["end"])
RANDOM_INTERVAL = get_config_value("Random", "interval", DEFAULTS["Random"]["interval"])
ROTATION_BASE = get_config_value("Rotation", "base", DEFAULTS["Rotation"]["base"])
ROTATION_END = get_config_value("Rotation", "end", DEFAULTS["Rotation"]["end"])
ROTATION_TIME = get_config_value("Rotation", "time", DEFAULTS["Rotation"]["time"])
SUDORANDOM_BASE = get_config_value("SudoRandom", "base", DEFAULTS["SudoRandom"]["base"])
SUDORANDOM_END = get_config_value("SudoRandom", "end", DEFAULTS["SudoRandom"]["end"])
SUDORANDOM_INTERVAL = get_config_value("SudoRandom", "interval", DEFAULTS["SudoRandom"]["interval"])
DIRECT_ENABLED = get_config_value("Direct", "enabled", DEFAULTS["Direct"]["enabled"], lambda x: str(x).lower() in ("1", "true", "yes"))
DIRECT_PREFIX = get_config_value("Direct", "prefix", DEFAULTS["Direct"]["prefix"])

random_bases = parse_int_list(RANDOM_BASE, fallback=3000, label="Random base", section="Random")
random_ends = parse_int_list(RANDOM_END, fallback=3099, label="Random end", section="Random")
random_intervals = parse_float_list(RANDOM_INTERVAL, fallback=10, label="Random interval", section="Random")
rotation_bases = parse_int_list(ROTATION_BASE, fallback=4000, label="Rotation base", section="Rotation")
rotation_ends = parse_int_list(ROTATION_END, fallback=4099, label="Rotation end", section="Rotation")
rotation_times = parse_float_list(ROTATION_TIME, fallback=10, label="Rotation time", section="Rotation")
sudo_bases = parse_int_list(SUDORANDOM_BASE, fallback=5000, label="SudoRandom base", section="SudoRandom")
sudo_ends = parse_int_list(SUDORANDOM_END, fallback=5099, label="SudoRandom end", section="SudoRandom")
sudo_intervals = parse_float_list(SUDORANDOM_INTERVAL, fallback=10, label="SudoRandom interval", section="SudoRandom")

def validate_config_pairs():
    for bases, ends, label, section in [
        (random_bases, random_ends, "Random", "Random"),
        (rotation_bases, rotation_ends, "Rotation", "Rotation"),
        (sudo_bases, sudo_ends, "SudoRandom", "SudoRandom")
    ]:
        for i, (b, e) in enumerate(zip(bases, ends)):
            if e < b:
                config_warnings.append(f"{label} config: End {e} < Base {b} (index {i})")
validate_config_pairs()
# --------------------------------------------------

GPIO.setmode(GPIO.BCM)
GPIO.setup(REMOTE_BUSY_PIN, GPIO.OUT)
GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
GPIO.setup(COS_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

try:
    serial_port = serial.Serial(
        port=SERIAL_PORT,
        baudrate=SERIAL_BAUDRATE,
        timeout=SERIAL_TIMEOUT
    )
    serial_port.reset_input_buffer()
except Exception as e:
    serial_port = None
    serial_port_missing = True

random_last_played = {}
random_current_track = {}
rotation_last_played = {}
rotation_current_track = {}

sudo_random_last_interval = {}
sudo_random_interval_track = {}
sudo_random_played_in_cycle = {}
sudo_random_last_file = {}

playback_interrupt = threading.Event()
alternate_sequences = {}

def log_error(msg):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        with open(log_file_path, 'a') as f:
            f.write(f"[{timestamp}] {msg}\n")
    except Exception:
        print(f"[{timestamp}] Logging failed: {msg}")

def log_exception(context: str):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    exc = traceback.format_exc()
    try:
        with open(log_file_path, 'a') as f:
            f.write(f"[{timestamp}] Exception in {context}:\n{exc}\n")
    except Exception:
        print(f"[{timestamp}] Logging failed: {exc}")

def log_recent(entry):
    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
    try:
        with open(LOG_WEB_FILE, "a") as f:
            f.write(f"{ts}: {entry}\n")
        # --- TRIM LOG FILE IF OVER 500 KB ---
        max_size = 500 * 1024  # 500 KB
        try:
            if os.path.getsize(LOG_WEB_FILE) > max_size:
                with open(LOG_WEB_FILE, "rb") as f:
                    f.seek(-max_size, os.SEEK_END)
                    data = f.read()
                # find first newline to avoid splitting a line
                first_nl = data.find(b'\n')
                if first_nl != -1:
                    data = data[first_nl+1:]
                with open(LOG_WEB_FILE, "wb") as f:
                    f.write(data)
        except Exception as e:
            pass  # If trimming fails, just ignore
    except Exception as e:
        log_error(f"log_recent failed: {e}")

if shutil.which("sox") is None:
    log_error("sox is not installed! 'P' mode will not work.")

def is_cos_active():
    override_enabled = config.getboolean('Debug', 'enable_cos_override', fallback=False) if config.has_section('Debug') else False
    override_path = "/tmp/cos_force"
    if override_enabled:
        try:
            with open(override_path, "r") as f:
                val = f.read().strip()
                if val == "1":
                    return True
                elif val == "0":
                    return False
        except FileNotFoundError:
            pass
        except Exception:
            log_exception("is_cos_active (override)")
    try:
        level = GPIO.input(COS_PIN)
        return (level == COS_ACTIVE_LEVEL)
    except Exception:
        log_exception("is_cos_active (GPIO.input)")
        return False

def parse_suffix_first(cmd):
    valid_suffixes = {'I', 'R', 'P'}
    for idx, c in enumerate(cmd):
        if c in valid_suffixes:
            return cmd[:idx], c
    return cmd, None

def parse_alternate_series(command):
    if not command.startswith("P"):
        return [], None, False
    tail = command[1:]
    tail, suffix = parse_suffix_first(tail)
    base_parts = tail.split("A")
    try:
        bases = []
        for s in base_parts:
            s = s.strip()
            if s.isdigit():
                bases.append(int(s))
        if len(bases) > 1:
            return bases, suffix, True
    except Exception:
        pass
    return [], None, False

def get_base_type_and_info(base):
    for bases, ends, intervals, typ in [
        (random_bases, random_ends, random_intervals, 'Random'),
        (rotation_bases, rotation_ends, rotation_times, 'Rotation'),
        (sudo_bases, sudo_ends, sudo_intervals, 'SudoRandom')
    ]:
        if base in bases:
            idx = bases.index(base)
            end = ends[idx]
            interval = intervals[idx] * 60
            return typ, end, interval
    return None, None, None

def play_any_section_by_type(base, end, interval, typ, interruptible, repeat, pausing):
    if typ == "Random":
        play_randomized_section(base, end, interval, random_last_played, random_current_track, interruptible)
    elif typ == "Rotation":
        play_rotating_section(base, end, interval, rotation_last_played, rotation_current_track, interruptible)
    elif typ == "SudoRandom":
        play_sudo_random_section(base, end, interval, sudo_random_last_interval, sudo_random_interval_track, sudo_random_played_in_cycle, interruptible, repeat, pausing)
    else:
        play_direct_track(f"{base:04d}", interruptible, repeat, pausing)

def find_matching_files(base, end):
    files = []
    try:
        for track_num in range(base + 1, end + 1):
            matching = [f for f in os.listdir(SOUND_DIRECTORY)
                        if match_code_file(f, f"{track_num:04d}", SOUND_FILE_EXTENSION)]
            files.extend([os.path.join(SOUND_DIRECTORY, f) for f in matching])
    except Exception:
        log_exception("find_matching_files")
    return files

def get_duration_wav(fname):
    try:
        with contextlib.closing(wave.open(fname, 'r')) as f:
            frames = f.getnframes()
            rate = f.getframerate()
            duration = frames / float(rate)
            return duration
    except Exception:
        log_exception("get_duration_wav")
        return 0

def play_sound(filename, interruptible=False, repeat=False, pausing=False, source="serial/auto"):
    global currently_playing, currently_playing_info, currently_playing_info_timestamp, playing_end_time, playback_interrupt, playback_status, sound_card_missing
    max_interrupts = MAX_COS_INTERRUPTIONS
    cos_interrupts = 0
    playback_interrupt.clear()
    currently_playing = os.path.basename(filename)
    currently_playing_info = f"Playing sound on device: {SOUND_DEVICE} - file: {filename} (Interruptible={interruptible}, Repeat={repeat}, Pausing={pausing})"
    currently_playing_info_timestamp = time.time()
    playing_end_time = currently_playing_info_timestamp + 5
    ret = None
    cos_interrupted = False  # Track if COS actually caused interruption

    try:
        GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)
        if repeat:
            while True:
                interrupted = False
                allow_interrupt = cos_interrupts < max_interrupts
                playback_status = "Playing"
                try:
                    proc = subprocess.Popen(
                        ['aplay', '-D', SOUND_DEVICE, filename],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                except FileNotFoundError:
                    sound_card_missing = True
                    currently_playing_info = "Sound card/device missing or aplay not found!"
                    ret = False
                    break
                except Exception as exc:
                    sound_card_missing = True
                    currently_playing_info = f"Sound card/device error: {exc}"
                    ret = False
                    break
                try:
                    while proc.poll() is None:
                        if allow_interrupt and is_cos_active():
                            playback_status = "Restarting"
                            proc.terminate()
                            time.sleep(0.2)
                            if proc.poll() is None:
                                proc.kill()
                            cos_interrupts += 1
                            interrupted = True
                            cos_interrupted = True
                            while is_cos_active() and not playback_interrupt.is_set():
                                time.sleep(0.05)
                            break
                        if playback_interrupt.is_set():
                            proc.terminate()
                            break
                        time.sleep(0.05)
                finally:
                    if proc.poll() is None:
                        proc.kill()
                    proc.wait()
                if interrupted and cos_interrupts < max_interrupts and not playback_interrupt.is_set():
                    continue
                if cos_interrupts >= max_interrupts and not playback_interrupt.is_set():
                    playback_status = "Playing"
                    try:
                        proc = subprocess.Popen(
                            ['aplay', '-D', SOUND_DEVICE, filename],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL
                        )
                    except FileNotFoundError:
                        sound_card_missing = True
                        currently_playing_info = "Sound card/device missing or aplay not found!"
                        ret = False
                        break
                    except Exception as exc:
                        sound_card_missing = True
                        currently_playing_info = f"Sound card/device error: {exc}"
                        ret = False
                        break
                    try:
                        while proc.poll() is None:
                            if playback_interrupt.is_set():
                                proc.terminate()
                                break
                            time.sleep(0.05)
                    finally:
                        if proc.poll() is None:
                            proc.kill()
                        proc.wait()
                    ret = proc.returncode == 0
                    break
                ret = proc.returncode == 0
                break
        elif pausing:
            total_duration = get_duration_wav(filename)
            played_duration = 0
            while played_duration < total_duration:
                sox_cmd = [
                    'sox', filename, '-t', 'wav', '-', 'trim', f'{played_duration}'
                ]
                try:
                    proc1 = subprocess.Popen(sox_cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
                    proc2 = subprocess.Popen(['aplay', '-D', SOUND_DEVICE], stdin=proc1.stdout, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    proc1.stdout.close()
                except FileNotFoundError:
                    sound_card_missing = True
                    currently_playing_info = "Sound card/device missing or aplay/sox not found!"
                    ret = False
                    break
                except Exception as exc:
                    sound_card_missing = True
                    currently_playing_info = f"Sound card/device error: {exc}"
                    ret = False
                    break
                interrupted = False
                start_time = time.time()
                playback_status = "Playing"
                while proc2.poll() is None:
                    if is_cos_active():
                        if cos_interrupts < max_interrupts:
                            playback_status = "Pausing"
                            proc2.terminate()
                            proc1.terminate()
                            time.sleep(0.1)
                            if proc2.poll() is None:
                                proc2.kill()
                            if proc1.poll() is None:
                                proc1.kill()
                            cos_interrupts += 1
                            interrupted = True
                            cos_interrupted = True
                            played_duration += time.time() - start_time
                            while is_cos_active() and not playback_interrupt.is_set():
                                time.sleep(0.05)
                            break
                        else:
                            proc2.terminate()
                            proc1.terminate()
                            if proc2.poll() is None:
                                proc2.kill()
                            if proc1.poll() is None:
                                proc1.kill()
                            played_duration = total_duration
                            ret = False
                            break
                    if playback_interrupt.is_set():
                        proc2.terminate()
                        proc1.terminate()
                        ret = False
                        break
                    time.sleep(0.05)
                if proc2.poll() is None:
                    proc2.kill()
                if proc1.poll() is None:
                    proc1.kill()
                if not interrupted or cos_interrupts >= max_interrupts or playback_interrupt.is_set():
                    break
            ret = True if not sound_card_missing else False
        else:
            playback_status = "Playing"
            cos_interrupted_local = False
            try:
                proc = subprocess.Popen(
                    ['aplay', '-D', SOUND_DEVICE, filename],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except FileNotFoundError:
                sound_card_missing = True
                currently_playing_info = "Sound card/device missing or aplay not found!"
                ret = False
            except Exception as exc:
                sound_card_missing = True
                currently_playing_info = f"Sound card/device error: {exc}"
                ret = False
            else:
                try:
                    while proc.poll() is None:
                        if interruptible and is_cos_active():
                            proc.terminate()
                            time.sleep(0.2)
                            if proc.poll() is None:
                                proc.kill()
                            cos_interrupted_local = True
                            cos_interrupted = True
                            break
                        if playback_interrupt.is_set():
                            proc.terminate()
                            break
                        time.sleep(0.05)
                finally:
                    if proc.poll() is None:
                        proc.kill()
                    proc.wait()
                ret = proc.returncode == 0
    except Exception:
        log_exception("play_sound")
        ret = False
    finally:
        playback_status = ""
        try:
            GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
        except Exception:
            log_exception("play_sound (GPIO cleanup)")
        currently_playing = ""
        currently_playing_info = ""
        currently_playing_info_timestamp = 0
        playing_end_time = 0

    # --- LOGGING FOR ALL PLAY ATTEMPTS ---
    if filename:
        if ret:
            log_recent(f"Play ({source}): {os.path.basename(filename)} - successful")
        elif interruptible and cos_interrupted:
            log_recent(f"Play ({source}): {os.path.basename(filename)} - interrupted -> playback stopped")
        else:
            log_recent(f"Play ({source}): {os.path.basename(filename)} - failed -> playback error")

def play_randomized_section(base, end, interval, last_played_dict, current_track_dict, interruptible=False):
    try:
        current_time = time.time()
        last_played = last_played_dict.get(base, 0)
        current_track = current_track_dict.get(base, None)
        matching_files = find_matching_files(base, end)
        if not matching_files:
            return
        if current_time - last_played >= interval or current_track not in matching_files:
            new_track = random.choice(matching_files)
            current_track_dict[base] = new_track
            last_played_dict[base] = current_time
        else:
            new_track = current_track
        threading.Thread(target=play_sound, args=(new_track, interruptible), kwargs={'source': "serial/auto"}).start()
    except Exception:
        log_exception("play_randomized_section")

def play_rotating_section(base, end, interval, last_played_dict, current_track_dict, interruptible=False, repeat=False, pausing=False):
    try:
        current_time = time.time()
        last_played = last_played_dict.get(base, 0)
        available_tracks = []
        # Collect all valid track numbers (i.e., for which a matching file exists)
        for track_num in range(base + 1, end + 1):
            matching_files = [f for f in os.listdir(SOUND_DIRECTORY)
                              if match_code_file(f, f"{track_num:04d}", SOUND_FILE_EXTENSION)]
            if matching_files:
                available_tracks.append(track_num)
        if not available_tracks:
            return
        # Determine which track to play
        if base not in current_track_dict or current_track_dict[base] not in available_tracks:
            current_track_num = available_tracks[0]
        else:
            current_track_num = current_track_dict[base]
        if last_played == 0:
            # First run, play current track and start timer
            next_track_num = current_track_num
            last_played_dict[base] = current_time
        elif current_time - last_played >= interval:
            # Interval expired, advance track and update timer
            idx = available_tracks.index(current_track_num) if current_track_num in available_tracks else 0
            next_idx = (idx + 1) % len(available_tracks)
            next_track_num = available_tracks[next_idx]
            last_played_dict[base] = current_time
        else:
            # Interval not expired, play current track but do NOT reset timer
            next_track_num = current_track_num
        # Find the matching file for the next track number
        matching_files = [f for f in os.listdir(SOUND_DIRECTORY)
                          if match_code_file(f, f"{next_track_num:04d}", SOUND_FILE_EXTENSION)]
        if not matching_files:
            return
        next_track = os.path.join(SOUND_DIRECTORY, matching_files[0])
        current_track_dict[base] = next_track_num
        threading.Thread(
            target=play_sound,
            args=(next_track, interruptible, repeat, pausing),
            kwargs={'source': "serial/auto"}
        ).start()
        rotation_active[base] = False
    except Exception:
        log_exception("play_rotating_section")
        rotation_active[base] = False

def play_sudo_random_section(base, end, interval, last_interval_dict, interval_track_dict, played_in_cycle_dict, interruptible=False, repeat=False, pausing=False):
    global sudo_random_last_file
    current_time = time.time()
    matching_files = find_matching_files(base, end)
    if not matching_files:
        return
    last_interval = last_interval_dict.get(base, 0)
    current_track = interval_track_dict.get(base)
    played_in_cycle = played_in_cycle_dict.get(base, set())
    if current_track is not None and (current_time - last_interval < interval) and current_track in matching_files:
        file_to_play = current_track
    else:
        unused_tracks = [t for t in matching_files if t not in played_in_cycle]
        if not unused_tracks:
            played_in_cycle = set()
            unused_tracks = matching_files[:]
        new_track = random.choice(unused_tracks)
        file_to_play = new_track
        interval_track_dict[base] = file_to_play
        last_interval_dict[base] = current_time
        played_in_cycle.add(file_to_play)
        played_in_cycle_dict[base] = played_in_cycle
    sudo_random_last_file[base] = file_to_play
    threading.Thread(target=play_sound, args=(file_to_play, interruptible, repeat, pausing), kwargs={'source': "serial/auto"}).start()

def play_direct_track(code_str, interruptible=False, repeat=False, pausing=False):
    matches = [f for f in os.listdir(SOUND_DIRECTORY)
               if match_code_file(f, code_str, SOUND_FILE_EXTENSION)]
    if matches:
        filename = os.path.join(SOUND_DIRECTORY, matches[0])
        threading.Thread(target=play_sound, args=(filename, interruptible, repeat, pausing), kwargs={'source': "serial/auto"}).start()
    else:
        log_recent(f"Play (serial/auto): {code_str}{SOUND_FILE_EXTENSION} - failed -> file not found")

def parse_serial_command(command):
    try:
        # Support PxxxxiYYYY for COS-i
        m = re.match(r'^P(\d{4})i(\d{4})$', command)
        if m:
            return (m.group(1), 'i', m.group(2))
        # Support alternate series
        bases, suffix, is_alt = parse_alternate_series(command)
        if is_alt:
            return (None, None, None)
        # Support Pxxxx, PxxxxI, etc.
        m = re.match(r'^P(\d{4})([IRP]?)$', command)
        if not m:
            m2 = re.match(r'^P(\d{4})([IRP])', command)
            if m2:
                return (m2.group(1), m2.group(2), None)
            return (None, None, None)
        return (m.group(1), m.group(2), None)
    except Exception:
        log_exception("parse_serial_command")
        return (None, None, None)

def auto_alternate_series(command, interval_per_base=60):
    bases, _, is_alt = parse_alternate_series(command)
    if not is_alt or not bases:
        print("Not a valid alternate series command.")
        return

    key = tuple(sorted(bases))
    pointer = 0

    while True:
        current_base = bases[pointer]
        process_command(command)
        print(f"Played base {current_base}, waiting {interval_per_base} seconds before next base...")
        time.sleep(interval_per_base)
        pointer = (pointer + 1) % len(bases)

def process_command(command):
    debug_log("process_command reached")
    debug_log(f"RAW process_command input: {repr(command)}")
    try:
        playback_interrupt.set()
        time.sleep(0.1)

        # --- ALTERNATE SERIES HANDLING ---
        bases, alt_suffix, is_alt = parse_alternate_series(command.strip())
        if is_alt and bases:
            debug_log(f"Alternate series detected: {bases}")
            interruptible = (alt_suffix == "I")
            repeat = (alt_suffix == "R")
            pausing = (alt_suffix == "P")
            key = tuple(sorted(bases))

            if key not in alternate_series_track_pointers:
                alternate_series_track_pointers[key] = {}
            if key not in alternate_series_last_played:
                alternate_series_last_played[key] = {}
            if key not in alternate_series_pointers:
                alternate_series_pointers[key] = 0

            pointer = alternate_series_pointers[key]
            track_pointers = alternate_series_track_pointers[key]
            last_played = alternate_series_last_played[key]

            base = bases[pointer]
            typ, end, interval = get_base_type_and_info(base)
            debug_log(f"Current base: {base}, type={typ}, end={end}, interval={interval}")
            now = time.time()
            last = last_played.get(base, 0)

            if typ == "Rotation":
                available_tracks = []
                for tnum in range(base + 1, end + 1):
                    for f in os.listdir(SOUND_DIRECTORY):
                        if match_code_file(f, f"{tnum:04d}", SOUND_FILE_EXTENSION):
                            available_tracks.append(tnum)
                            break
                if not available_tracks:
                    pointer = (pointer + 1) % len(bases)
                    alternate_series_pointers[key] = pointer
                    return

                cur_track_num = track_pointers.get(base, available_tracks[0])
                if last == 0:
                    play_track_num = available_tracks[0]
                    track_pointers[base] = play_track_num
                    last_played[base] = now
                elif now - last >= interval:
                    idx = available_tracks.index(cur_track_num)
                    next_idx = (idx + 1) % len(available_tracks)
                    play_track_num = available_tracks[next_idx]
                    track_pointers[base] = play_track_num
                    last_played[base] = now
                else:
                    play_track_num = cur_track_num

                debug_log(f"[ALT-ROT] base={base}, cur={cur_track_num}, play={play_track_num}, last={last}, now={now}, pointer={pointer}, available={available_tracks}")

                matching_files = [f for f in os.listdir(SOUND_DIRECTORY)
                                  if match_code_file(f, f"{play_track_num:04d}", SOUND_FILE_EXTENSION)]
                if matching_files:
                    filename = os.path.join(SOUND_DIRECTORY, matching_files[0])
                    threading.Thread(target=play_sound, args=(filename, interruptible, repeat, pausing), kwargs={'source': "serial/auto"}).start()

                alternate_series_track_pointers[key] = track_pointers
                alternate_series_last_played[key] = last_played
                pointer = (pointer + 1) % len(bases)
                alternate_series_pointers[key] = pointer
                return

            elif typ == "Random":
                files = find_matching_files(base, end)
                if not files:
                    pointer = (pointer + 1) % len(bases)
                    alternate_series_pointers[key] = pointer
                    return
                current_track = track_pointers.get(base, None)
                if last == 0 or now - last >= interval or not current_track or os.path.basename(current_track) not in [os.path.basename(f) for f in files]:
                    chosen = random.choice(files)
                    track_pointers[base] = os.path.basename(chosen)
                    last_played[base] = now
                else:
                    chosen = None
                    for f in files:
                        if os.path.basename(f) == current_track:
                            chosen = f
                            break
                    if not chosen:
                        chosen = random.choice(files)
                        track_pointers[base] = os.path.basename(chosen)
                        last_played[base] = now
                threading.Thread(target=play_sound, args=(chosen, interruptible, repeat, pausing), kwargs={'source': "serial/auto"}).start()

            elif typ == "SudoRandom":
                files = find_matching_files(base, end)
                if not files:
                    pointer = (pointer + 1) % len(bases)
                    alternate_series_pointers[key] = pointer
                    return
                played_key = f"{base}_played"
                played = track_pointers.get(played_key, set())
                if not isinstance(played, set):
                    played = set(played)
                current_track = track_pointers.get(base, None)
                if current_track is not None and (now - last < interval) and current_track in [os.path.basename(f) for f in files]:
                    chosen = None
                    for f in files:
                        if os.path.basename(f) == current_track:
                            chosen = f
                            break
                    if not chosen:
                        chosen = random.choice(files)
                        track_pointers[base] = os.path.basename(chosen)
                        last_played[base] = now
                        played.add(os.path.basename(chosen))
                        track_pointers[played_key] = played
                else:
                    unused = [f for f in files if os.path.basename(f) not in played]
                    if not unused:
                        played = set()
                        unused = files[:]
                    chosen = random.choice(unused)
                    track_pointers[base] = os.path.basename(chosen)
                    last_played[base] = now
                    played.add(os.path.basename(chosen))
                    track_pointers[played_key] = played
                threading.Thread(target=play_sound, args=(chosen, interruptible, repeat, pausing), kwargs={'source': "serial/auto"}).start()

            else:
                pointer = (pointer + 1) % len(bases)
                alternate_series_pointers[key] = pointer
                return

            alternate_series_track_pointers[key] = track_pointers
            alternate_series_last_played[key] = last_played
            pointer = (pointer + 1) % len(bases)
            alternate_series_pointers[key] = pointer
            return

        # --- EVERYTHING ELSE (original logic follows) ---
        code_str, suffix, alt_code = parse_serial_command(command.strip())
        if code_str is None:
            return

        debug_log(f"rotation_bases: {rotation_bases}, types: {[type(x) for x in rotation_bases]}")
        debug_log(f"code: {code_str}, type: {type(code_str)}")
        code = int(code_str)
        debug_log(f"code (int): {code}, type: {type(code)}")

        # --- COS-i logic: use base logic unless COS triggers ---
        if suffix == 'i' and alt_code is not None:
            log_recent(f"[COS-i] Handling P{code_str}i{alt_code}")
            base_code = int(code_str)
            typ, end, interval = get_base_type_and_info(base_code)

            if typ == "Rotation":
                available_tracks = []
                for track_num in range(base_code + 1, end + 1):
                    for f in os.listdir(SOUND_DIRECTORY):
                        if match_code_file(f, f"{track_num:04d}", SOUND_FILE_EXTENSION):
                            available_tracks.append((track_num, f))
                            break
                if not available_tracks:
                    log_recent(f"[COS-i] No available tracks for base {base_code} (Rotation)")
                    return
                available_nums = [num for num, _ in available_tracks]
                current_num = rotation_current_track.get(base_code, available_nums[0])
                if current_num not in available_nums:
                    current_num = available_nums[0]
                idx = available_nums.index(current_num)
                now = time.time()
                last_played = rotation_last_played.get(base_code, 0)
                if last_played == 0:
                    next_idx = idx
                    rotation_last_played[base_code] = now
                elif now - last_played >= interval:
                    next_idx = (idx + 1) % len(available_nums)
                    rotation_last_played[base_code] = now
                else:
                    next_idx = idx
                rotation_current_track[base_code] = available_nums[next_idx]
                base_filename = os.path.join(SOUND_DIRECTORY, available_tracks[next_idx][1])
            elif typ == "Random":
                matching_files = find_matching_files(base_code, end)
                if not matching_files:
                    log_recent(f"[COS-i] No matching files for base {base_code} (Random)")
                    return
                last_played = random_last_played.get(base_code, 0)
                current_track = random_current_track.get(base_code, None)
                now = time.time()
                if now - last_played >= interval or current_track not in matching_files:
                    base_filename = random.choice(matching_files)
                    random_current_track[base_code] = base_filename
                    random_last_played[base_code] = now
                else:
                    base_filename = current_track
            elif typ == "SudoRandom":
                matching_files = find_matching_files(base_code, end)
                if not matching_files:
                    log_recent(f"[COS-i] No matching files for base {base_code} (SudoRandom)")
                    return
                played_in_cycle = sudo_random_played_in_cycle.get(base_code, set())
                if not isinstance(played_in_cycle, set):
                    played_in_cycle = set(played_in_cycle)
                unused_tracks = [t for t in matching_files if t not in played_in_cycle]
                if not unused_tracks:
                    played_in_cycle = set()
                    unused_tracks = matching_files[:]
                base_filename = random.choice(unused_tracks)
                sudo_random_interval_track[base_code] = base_filename
                sudo_random_last_interval[base_code] = time.time()
                played_in_cycle.add(base_filename)
                sudo_random_played_in_cycle[base_code] = played_in_cycle
            else:
                base_filename = os.path.join(SOUND_DIRECTORY, f"{code_str}{SOUND_FILE_EXTENSION}")

            filename2 = os.path.join(SOUND_DIRECTORY, f"{alt_code}{SOUND_FILE_EXTENSION}")

            def cos_i_sequence():
                global currently_playing, currently_playing_info, currently_playing_info_timestamp, playing_end_time, playback_status
                try:
                    currently_playing = os.path.basename(base_filename)
                    currently_playing_info = f"[COS-i] Step 1: Playing {base_filename} (COS interruptible)"
                    currently_playing_info_timestamp = time.time()
                    playing_end_time = currently_playing_info_timestamp + 5
                    GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)

                    proc = subprocess.Popen(
                        ['aplay', '-D', SOUND_DEVICE, base_filename],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                    cos_triggered = False
                    while proc.poll() is None:
                        if is_cos_active():
                            log_recent("[COS-i] COS went ACTIVE, stopping 1st file.")
                            proc.terminate()
                            cos_triggered = True
                            break
                        time.sleep(0.05)
                    if proc.poll() is None:
                        proc.kill()
                    proc.wait()
                    GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
                    if not cos_triggered:
                        return
                    log_recent("[COS-i] Interrupt triggered, playing 2nd file immediately")
                    log_recent(f"[COS-i] Step 2: Playing {filename2} (UNinterruptible)")
                    currently_playing = os.path.basename(filename2)
                    currently_playing_info = f"[COS-i] Step 2: Playing {filename2} (UNinterruptible)"
                    currently_playing_info_timestamp = time.time()
                    playing_end_time = currently_playing_info_timestamp + 5
                    GPIO.output(REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL)
                    proc2 = subprocess.Popen(['aplay', '-D', SOUND_DEVICE, filename2])
                    proc2.wait()
                    GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
                    log_recent("[COS-i] Sequence complete.")
                except Exception:
                    log_exception("cos_i_sequence")
                finally:
                    GPIO.output(REMOTE_BUSY_PIN, not REMOTE_BUSY_ACTIVE_LEVEL)
                    currently_playing = ""
                    currently_playing_info = ""
                    currently_playing_info_timestamp = 0
                    playing_end_time = 0

            threading.Thread(target=cos_i_sequence, daemon=True).start()
            return

        interruptible = (suffix == "I")
        repeat = (suffix == "R")
        pausing = (suffix == "P")
        code = int(code_str)
        for b, e, t in zip(random_bases, random_ends, random_intervals):
            if code == b:
                play_randomized_section(b, e, t * 60, random_last_played, random_current_track, interruptible)
                return
            elif b < code <= e:
                play_direct_track(code_str, interruptible, repeat, pausing)
                return
        for b, e, t in zip(rotation_bases, rotation_ends, rotation_times):
            if code == b:
                if not rotation_active.get(b, False):
                    rotation_active[b] = True
                    play_rotating_section(b, e, t * 60, rotation_last_played, rotation_current_track, interruptible, repeat, pausing)
                else:
                    debug_log(f"Rotation for base {b} is already active, ignoring repeat trigger.")
                return
            elif b < code <= e:
                play_direct_track(code_str, interruptible, repeat, pausing)
                return
        for b, e, t in zip(sudo_bases, sudo_ends, sudo_intervals):
            if code == b:
                play_sudo_random_section(
                    b, e, t * 60,
                    sudo_random_last_interval,
                    sudo_random_interval_track,
                    sudo_random_played_in_cycle,
                    interruptible, repeat, pausing
                )
                return
            elif b < code <= e:
                play_direct_track(code_str, interruptible, repeat, pausing)
                return
        if DIRECT_ENABLED:
            play_direct_track(code_str, interruptible, repeat, pausing)
    except Exception:
        log_exception("process_command")

def reload_config():
    global config, SOUND_DIRECTORY, SOUND_FILE_EXTENSION, SOUND_DEVICE, COS_PIN, COS_ACTIVE_LEVEL, REMOTE_BUSY_PIN, REMOTE_BUSY_ACTIVE_LEVEL, COS_DEBOUNCE_TIME, MAX_COS_INTERRUPTIONS, SERIAL_PORT, SERIAL_BAUDRATE, SERIAL_TIMEOUT, RANDOM_BASE, RANDOM_END, RANDOM_INTERVAL, ROTATION_BASE, ROTATION_END, ROTATION_TIME, SUDORANDOM_BASE, SUDORANDOM_END, SUDORANDOM_INTERVAL, DIRECT_ENABLED, DIRECT_PREFIX, random_bases, random_ends, random_intervals, rotation_bases, rotation_ends, rotation_times, sudo_bases, sudo_ends, sudo_intervals, config_warnings
    config = configparser.ConfigParser()
    config.read(config_file_path)
    config_warnings = []
    ENABLE_DEBUG_LOGGING = get_config_value("Debug", "enable_debug_logging", "false", lambda x: str(x).lower() in ("1", "true", "yes"))
    SOUND_DIRECTORY = get_config_value("Sound", "directory", DEFAULTS["Sound"]["directory"])
    SOUND_FILE_EXTENSION = get_config_value("Sound", "extension", DEFAULTS["Sound"]["extension"])
    SOUND_DEVICE = get_config_value("Sound", "device", DEFAULTS["Sound"]["device"])
    COS_PIN = get_config_value("GPIO", "cos_pin", DEFAULTS["GPIO"]["cos_pin"], int)
    COS_ACTIVE_LEVEL = get_config_value("GPIO", "cos_activate_level", DEFAULTS["GPIO"]["cos_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
    REMOTE_BUSY_PIN = get_config_value("GPIO", "remote_busy_pin", DEFAULTS["GPIO"]["remote_busy_pin"], int)
    REMOTE_BUSY_ACTIVE_LEVEL = get_config_value("GPIO", "remote_busy_activate_level", DEFAULTS["GPIO"]["remote_busy_activate_level"], lambda x: str(x).lower() in ('1', 'true', 'yes'))
    COS_DEBOUNCE_TIME = get_config_value("GPIO", "cos_debounce_time", DEFAULTS["GPIO"]["cos_debounce_time"], float)
    MAX_COS_INTERRUPTIONS = get_config_value("GPIO", "max_cos_interruptions", DEFAULTS["GPIO"]["max_cos_interruptions"], int)
    SERIAL_PORT = get_config_value("Serial", "port", DEFAULTS["Serial"]["port"])
    SERIAL_BAUDRATE = get_config_value("Serial", "baudrate", DEFAULTS["Serial"]["baudrate"], int)
    SERIAL_TIMEOUT = get_config_value("Serial", "timeout", DEFAULTS["Serial"]["timeout"], float)
    RANDOM_BASE = get_config_value("Random", "base", DEFAULTS["Random"]["base"])
    RANDOM_END = get_config_value("Random", "end", DEFAULTS["Random"]["end"])
    RANDOM_INTERVAL = get_config_value("Random", "interval", DEFAULTS["Random"]["interval"])
    ROTATION_BASE = get_config_value("Rotation", "base", DEFAULTS["Rotation"]["base"])
    ROTATION_END = get_config_value("Rotation", "end", DEFAULTS["Rotation"]["end"])
    ROTATION_TIME = get_config_value("Rotation", "time", DEFAULTS["Rotation"]["time"])
    SUDORANDOM_BASE = get_config_value("SudoRandom", "base", DEFAULTS["SudoRandom"]["base"])
    SUDORANDOM_END = get_config_value("SudoRandom", "end", DEFAULTS["SudoRandom"]["end"])
    SUDORANDOM_INTERVAL = get_config_value("SudoRandom", "interval", DEFAULTS["SudoRandom"]["interval"])
    DIRECT_ENABLED = get_config_value("Direct", "enabled", DEFAULTS["Direct"]["enabled"], lambda x: str(x).lower() in ("1", "true", "yes"))
    DIRECT_PREFIX = get_config_value("Direct", "prefix", DEFAULTS["Direct"]["prefix"])
    random_bases = parse_int_list(RANDOM_BASE, fallback=3000, label="Random base", section="Random")
    random_ends = parse_int_list(RANDOM_END, fallback=3099, label="Random end", section="Random")
    random_intervals = parse_float_list(RANDOM_INTERVAL, fallback=10, label="Random interval", section="Random")
    rotation_bases = parse_int_list(ROTATION_BASE, fallback=4000, label="Rotation base", section="Rotation")
    rotation_ends = parse_int_list(ROTATION_END, fallback=4099, label="Rotation end", section="Rotation")
    rotation_times = parse_float_list(ROTATION_TIME, fallback=10, label="Rotation time", section="Rotation")
    sudo_bases = parse_int_list(SUDORANDOM_BASE, fallback=5000, label="SudoRandom base", section="SudoRandom")
    sudo_ends = parse_int_list(SUDORANDOM_END, fallback=5099, label="SudoRandom end", section="SudoRandom")
    sudo_intervals = parse_float_list(SUDORANDOM_INTERVAL, fallback=10, label="SudoRandom interval", section="SudoRandom")
    validate_config_pairs()

# (Remaining functions already shown in previous parts...)

# The rest of your main loop and startup logic:
def main():
    try:
        threading.Thread(target=serial_read_loop, daemon=True).start()
        threading.Thread(target=process_serial_commands, daemon=True).start()
        threading.Thread(target=bg_write_state_and_webcmd_loop, daemon=True).start()
        threading.Thread(target=bg_cos_state_update_loop, daemon=True).start()
        try:
            curses.wrapper(status_screen)
        except Exception as e:
            print("Curses UI failed to start. Falling back to command prompt mode.")
            log_exception("main (curses fallback)")
            fallback_command_prompt()  # <-- This now exits cleanly
            # Remove the following lines!
            # while True:
            #     time.sleep(1)
    except KeyboardInterrupt:
        pass
    except Exception:
        log_exception("main")
    finally:
        try:
            GPIO.cleanup()
        except Exception:
            log_exception("main (GPIO cleanup)")